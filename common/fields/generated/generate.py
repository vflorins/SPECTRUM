"""
File generate.py Created by Lucius Schoenbaum March 30, 2025
Revised May 26, 2025
Choice of names set by SPECTRUM team on Friday August 1, 2025
Revised August 3, 2025

todo revise docstring after Fields/Variables revision

A code generator for `MHDtuple`, to facilitate revisions to the set of
formatted variables to be used within SPECTRUM.
This code generator is not intended to be run when SPECTRUM is compiled,
but rather only run whenever the variables and/or associated tools
(all of which is wrapped inside the class MHDtuple) are revised.

Revisions to variables are achieved by modifying the string
arguments to `Variable` and `Tuple` instances in the lists
`variables` and `tuples` (see below), or by adding or subtracting from
these lists. Other revisions to `MHDtuple` are possible by modifying the
generated code in other local areas, as needed.

To run:
In the directory of <this file>:
```shell
python3 <this file>
```

*Notes and Comments*

(1)
A code generator is used because any modification
to the basic set of variables imposes a major and bug-prone update
across multiple zones of the MHDtuple codebase, which (for realistic
lists of variables) is at least two thousand lines of code.
In short, although a code generator is burdensome,
the alternative of managing the files as ordinary source files would
be even more burdensome.

(2)
The files in /variables/ are organized as follows: all source files in the
directory /generate/ are generated by this file, all source files in the
directory /mhdtuple/ are modified (but not generated) by this file,
and files in the directory /variables/ itself are ordinary source code files.

(3)
If it is necessary to edit the files in /mhdtuple/, users may find it convenient
to run `generate.py` with empty lists for `variables` and `groups`,
editing the files, and then re-running generate.py with the desired
lists for `variables` and `groups`. This will make the files in /mhdtuple/
more surveyable and more practical as source files.

"""

from os.path import (
    join as os_path_join
)
from re import (
    split as re_split
)


class Field:
    """
    A convenience class for expressing the essential
    components of a formatted SPECTRUM variable, or field.
    """

    def __init__(self, name, datatype, description, R, S):
        self.name = name
        self.datatype = datatype
        self.description = description
        self.R = R
        self.S = S

    def fieldtype(self):
        if self.datatype == 'Scalar':
            return 'ScalarField'
        elif self.datatype == 'GeoVector':
            return 'VectorField'
        elif self.datatype == 'GeoMatrix':
            return 'MatrixField'
        else:
            raise ValueError

class FieldGroup:
    """
    A convenience class for expressing the essential
    components of a formatted SPECTRUM group of variables, or fields.
    """

    def __init__(self, name, typelist, description):
        self.name = name
        self.typelist = typelist
        self.description = description

empty_field_lists = False
# empty_field_lists = True

if empty_field_lists:
    fields = []
    groups = []
else:
    fields = [
        # Fluid fields:
        Field("Den", "Scalar", "Fluid density field", R = 1, S = 1),
        Field("Prs", "Scalar", "Fluid pressure field", R = 1, S = 1),
        Field("Enr", "Scalar", "Fluid energy field", R = 1, S = 1),
        Field("Vel", "GeoVector", "Fluid velocity field", R = 1, S = 0),
        Field("Mom", "GeoVector", "Fluid momentum field", R = 1, S = 0),
        Field("FlxDen", "Scalar", "Fluid density flux function", R = 1, S = 1),
        Field("FlxMom", "GeoVector", "Fluid momentum flux function", R = 1, S = 0),
        Field("FlxEnr", "Scalar", "Fluid energy flux function", R = 1, S = 0),
        # MHD fields (extending Fluid fields):
        Field("Mag", "GeoVector", "Magnetic field", R = 1, S = 0),
        Field("FlxMag", "GeoVector", "Magnetic field flux function", R = 1, S = 0),
        Field("Glm", "Scalar", "Lagrange multiplier field of GLM MHD", R = 1, S = 0),
        Field("FlxGlm", "Scalar", "Lagrange mutlipler flux function of GLM MHD", R = 1, S = 0),
        # Tracer fields:
        Field("Elc", "GeoVector", "Electric field", R = 1, S = 0),
        Field("AbsMag", "Scalar", "Magnetic field magnitude", R = 1, S = 0),
        Field("HatMag", "GeoVector", "Magnetic field direction", R = 1, S = 0),
        Field("DelVel", "GeoMatrix", "Gradient of velocity field", R = 1, S = 0),
        Field("DelElc", "GeoMatrix", "Gradient of electric field", R = 1, S = 0),
        Field("DelMag", "GeoMatrix", "Gradient of magnetic field", R = 1, S = 0),
        Field("DelAbsMag", "GeoVector", "Gradient of magnetic field magnitude", R = 1, S = 0),
        Field("DelHatMag", "GeoMatrix", "Gradient of magnetic field direction ", R = 1, S = 0),
        Field("DerVel", "GeoVector", "Time derivative of velocity field", R = 1, S = 0),
        Field("DerElc", "GeoVector", "Time derivative of electric field", R = 1, S = 0),
        Field("DerMag", "GeoVector", "Time derivative of magnetic field", R = 1, S = 0),
        Field("DerAbsMag", "Scalar", "Time derivative of magnetic field magnitude", R = 1, S = 0),
        Field("DerHatMag", "GeoVector", "Time derivative of magnetic field direction", R = 1, S = 0),
    ]
    groups = [
        # Fluid groups:
        FieldGroup("PrimitiveStateGASDYN", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for a gas dynamics model"),
        FieldGroup("ConservedStateGASDYN", "Den_t, Mom_t, Enr_t", "Fields of the conserved form for a gas dynamics model"),
        FieldGroup("FluxFunctionGASDYN", "FlxDen_t, FlxMom_t, FlxEnr_t", "Fields of the flux function for a gas dynamics model"),
        # MHD groups:
        FieldGroup("PrimitiveStateMHD", "Den_t, Vel_t, Prs_t, Mag_t", "Fields of the primitive form for an MHD model"),
        FieldGroup("ConservedStateMHD", "Den_t, Mom_t, Enr_t, Mag_t", "Fields of the conserved form for an MHD model"),
        FieldGroup("FluxFunctionMHD", "FlxDen_t, FlxMom_t, FlxEnr_t, FlxMag_t", "Fields of the flux function for an MHD model"),
        FieldGroup("PrimitiveStateMHD_GLM", "Den_t, Vel_t, Prs_t, Mag_t, Glm_t", "Fields of the primitive form for an MHD-GLM model"),
        FieldGroup("ConservedStateMHD_GLM", "Den_t, Mom_t, Enr_t, Mag_t, Glm_t", "Fields of the conserved form for an MHD-GLM model"),
        FieldGroup("FluxFunctionMHD_GLM", "FlxDen_t, FlxMom_t, FlxEnr_t, FlxMag_t, FlxGlm_t", "Fields of the flux function for an MHD-GLM model"),
    ]

generator = "generate.py"
partially_generated_path = f"../partially_generated/"

def file_header(fname):
    x = f"""/*!
\\file {fname}
\\author Vladimir Florinski
\\author Lucius Schoenbaum
\\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/
"""
    x +=  f"""
/*
This file is automatically generated by {generator}. 
Do not edit this file, instead edit {generator}. 
*/
"""
    return x




def generate_field_lists():
    """
    Generate file `field_lists.hh`.
    """
    fname = "field_lists.hh"
    size = len(fields) + len(groups)
    field_lists_parts = [
"""
#ifndef SPECTRUM_FIELD_LISTS_HH
#define SPECTRUM_FIELD_LISTS_HH

#include <array>

namespace Spectrum {

/*!
Identifiers for distinguished code-wide fields (for lookup).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
enum FieldId {
anon,
""",
f"""}};

/*!
Formatted names for distinguished code-wide fields
(minimal formatting in ASCII).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
const constexpr std::array<std::string_view, {size+1}> FieldNames = {{
   std::string_view(""),
""",
"""};

// Note: more maps can be added (e.g. unit/scale factor)

}

#endif
""",
    ]
    x = file_header(fname) + field_lists_parts[0]
    for field in fields + groups:
        x += f"{field.name},\n"
    x += field_lists_parts[1]
    for field in fields + groups:
        x += f'   std::string_view("{field.name}"),\n'
    x += field_lists_parts[2]
    with open(f"field_lists.hh", 'w') as f:
        f.write(x)





def generate_field_types():
    """
    Generate file `field_types.hh`.
    This file defines the fields as NamedFields classes,
    based on the list `fields`.
    """
    fname = "field_types.hh"
    field_types_parts = [
"""
#ifndef SPECTRUM_FIELD_TYPES_HH
#define SPECTRUM_FIELD_TYPES_HH

#include "../field_structs.hh"

namespace Spectrum {

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + field_types_parts[0]
    for field in fields:
        x += f"/*!\n\\brief {field.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {field.name}_t = {field.fieldtype()}<FieldId::{field.name}, {field.R}, {field.S}>;\n\n"
    x += field_types_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def generate_field_groups():
    """
    Generate file `field_groups.hh`.
    This file contains types that depend on NamedFields,
    based on the list `groups`. Groups are accessible in Fields.
    """
    fname = "field_groups.hh"
    field_groups_parts = [
f"""
#ifndef SPECTRUM_FIELD_GROUPS_HH
#define SPECTRUM_FIELD_GROUPS_HH

#include "{partially_generated_path}namedfields.hh"

namespace Spectrum {{

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + field_groups_parts[0]
    for grp in groups:
        x += f"/*!\n\\brief {grp.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {grp.name}_t = NamedFields<FieldId::{grp.name}, {grp.typelist}>;\n\n"
    x += field_groups_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def inject_fields():
    """
    Works similarly to the other methods, but
    instead of generating the entire file `namedfields.hh` and `fields.hh`,
    it injects into those parts of these files that depend on the generated code.
    These files define the NamedFields and Fields classes.
    The part of those files that is automatically generated is bounded by
    pragmas
    ```
        // BEGIN(fields/generate, <base>)

        ...

        // END(fields/generate, <base>)
    ```
    The files `namedfields.hh` and `fields.hh` should not be modified
    within these pragmas (their contents can be modified by modifying `generate.py`.
    However, outside of them, these files are like any other source code file.
    """
    for level in [0, 1]:
        named = "Named" if level == 0 else ""
        fieldid = "nameid, " if level == 0 else ""
        fname = f"{named.lower()}fields.hh"
        fpath = os_path_join(partially_generated_path, fname)
        with open(fpath, 'r') as f:
            content = f.read()
        injectee_labels = ['class', 'base']
        for injectee_label in injectee_labels:
            label = injectee_label
            pattern = f"\n.*fields/generate,\s*{label}.*\n"
            groups = re_split(pattern, content)
            content = groups[0] + get_injectee(label, named, fieldid) + groups[2]
        with open(fpath, 'w') as f:
            f.write(content)


def get_injectee(injectee_label, named, fieldid):
    """

    :param injectee_label: 'base' or 'class'
    :param named:
    :param fieldid:
    :return:
    """
    fieldlist = fields if named else fields+groups
    x = f"\n   // BEGIN(fields/generate, {injectee_label})\n"
    if injectee_label == 'class':
        for field in fieldlist:
            name = field.name
            description = field.description
            x += f"""
/*!
\\brief Get {name} ({description}) from the data type, as lvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   {name}_t& {name}(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return data;
      else
         return {named}Fields<{fieldid}Ts...>::{name}();
   }};

/*!
\\brief Get {name} ({description}) from the data type, as const rvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   const {name}_t& {name}(void) const {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return data;
      else
         return {named}Fields<{fieldid}Ts...>::{name}();
   }};


/*!
\\brief Whether {name} ({description}) is in the data type.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return true;
      else
         return {named}Fields<{fieldid}Ts...>::{name}_found();
   }};
   
"""
    elif injectee_label == 'base':
        for field in fieldlist:
            name = field.name
            description = field.description
            x += f"""
   {name}_t& {name}(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return data;
      else
        throw std::invalid_argument( "[{named}Fields] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   }};
   
  const {name}_t& {name}(void) const {{
   if constexpr (std::is_same<T, {name}_t>::value)
      return data;
   else
      throw std::invalid_argument( "[{named}Fields] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   }};
   
   bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return true;
      else
         return false;
   }};
"""
    x += f"\n   // END(fields/generate, {injectee_label})\n"
    return x




if __name__ == '__main__':

    generate_field_lists()
    generate_field_types()
    generate_field_groups()
    inject_fields()


