"""
File generate.py Created by Lucius Schoenbaum March 30, 2025
Revised May 26, 2025
Choice of names set by SPECTRUM team on Friday August 1, 2025
Revised August 3, 2025

todo revise docstring after Fields/Variables revision

A code generator for `MHDtuple`, to facilitate revisions to the set of
formatted variables to be used within SPECTRUM.
This code generator is not intended to be run when SPECTRUM is compiled,
but rather only run whenever the variables and/or associated tools
(all of which is wrapped inside the class MHDtuple) are revised.

Revisions to variables are achieved by modifying the string
arguments to `Variable` and `Tuple` instances in the lists
`variables` and `tuples` (see below), or by adding or subtracting from
these lists. Other revisions to `MHDtuple` are possible by modifying the
generated code in other local areas, as needed.

To run:
In the directory of <this file>:
```shell
python3 <this file>
```

*Notes and Comments*

(1)
A code generator is used because any modification
to the basic set of variables imposes a major and bug-prone update
across multiple zones of the MHDtuple codebase, which (for realistic
lists of variables) is at least two thousand lines of code.
In short, although a code generator is burdensome,
the alternative of managing the files as ordinary source files would
be even more burdensome.

(2)
The files in /variables/ are organized as follows: all source files in the
directory /generate/ are generated by this file, all source files in the
directory /mhdtuple/ are modified (but not generated) by this file,
and files in the directory /variables/ itself are ordinary source code files.

(3)
If it is necessary to edit the files in /mhdtuple/, users may find it convenient
to run `generate.py` with empty lists for `variables` and `groups`,
editing the files, and then re-running generate.py with the desired
lists for `variables` and `groups`. This will make the files in /mhdtuple/
more surveyable and more practical as source files.

"""

from os.path import (
    join as os_path_join
)
from re import (
    split as re_split
)


class Field:
    """
    A convenience class for expressing the essential
    components of a formatted SPECTRUM variable, or field.
    """

    def __init__(self, name, datatype, description, R, S, printed_name=None):
        self.name = name
        self.datatype = datatype
        self.description = description
        self.R = R
        self.S = S
        self.printed_name = printed_name

    def fieldtype(self):
        if self.datatype == 'Scalar':
            return 'ScalarField'
        elif self.datatype == 'GeoVector':
            return 'VectorField'
        elif self.datatype == 'GeoMatrix':
            return 'MatrixField'
        else:
            raise ValueError

class Species:
    """
    A convenience class for expressing the basic components of a species.
    """

    def __init__(self, name, typelist, description, printed_name=None):
        self.name = name
        self.typelist = typelist
        self.description = description
        self.printed_name = printed_name

empty_field_lists = False
# empty_field_lists = True

if empty_field_lists:
    fields = []
    species = []
else:
    fields = [
        # Geometric fields:
        Field("Pos", "GeoVector", "Position in space", R=0, S=0),
        Field("Time", "Scalar", "Time", R=0, S=0),
        # Fluid fields:
        Field("Den", "Scalar", "Density field", R = 1, S = 1),
        Field("Prs", "Scalar", "Pressure field", R = 1, S = 1),
        Field("Enr", "Scalar", "Energy field", R = 1, S = 1),
        Field("Vel", "GeoVector", "Velocity field", R = 1, S = 0),
        Field("Mom", "GeoVector", "Momentum field", R = 1, S = 0),
        Field("FlxDen", "Scalar", "Fluid density flux function", R = 1, S = 1),
        Field("FlxMom", "GeoVector", "Fluid momentum flux function", R = 1, S = 0),
        Field("FlxEnr", "Scalar", "Fluid energy flux function", R = 1, S = 0),
        # MHD fields (extending Fluid fields):
        Field("Mag", "GeoVector", "Magnetic field", R = 1, S = 0),
        Field("FlxMag", "GeoVector", "Magnetic field flux function", R = 1, S = 0),
        Field("Glm", "Scalar", "Lagrange multiplier field of GLM MHD", R = 1, S = 0),
        Field("FlxGlm", "Scalar", "Lagrange mutlipler flux function of GLM MHD", R = 1, S = 0),
        # Tracer fields:
        Field("Elc", "GeoVector", "Electric field", R = 1, S = 0),
        Field("AbsMag", "Scalar", "Magnetic field magnitude", R = 1, S = 0),
        Field("HatMag", "GeoVector", "Magnetic field direction", R = 1, S = 0),
        Field("DelVel", "GeoMatrix", "Gradient of velocity field", R = 1, S = 0),
        Field("DelElc", "GeoMatrix", "Gradient of electric field", R = 1, S = 0),
        Field("DelMag", "GeoMatrix", "Gradient of magnetic field", R = 1, S = 0),
        Field("DelAbsMag", "GeoVector", "Gradient of magnetic field magnitude", R = 1, S = 0),
        Field("DelHatMag", "GeoMatrix", "Gradient of magnetic field direction ", R = 1, S = 0),
        Field("DdtVel", "GeoVector", "Time derivative of velocity field", R = 1, S = 0),
        Field("DdtElc", "GeoVector", "Time derivative of electric field", R = 1, S = 0),
        Field("DdtMag", "GeoVector", "Time derivative of magnetic field", R = 1, S = 0),
        Field("DdtAbsMag", "Scalar", "Time derivative of magnetic field magnitude", R = 1, S = 0),
        Field("DdtHatMag", "GeoVector", "Time derivative of magnetic field direction", R = 1, S = 0),
        # Indicator Fields/Variables:
        Field("Iv0", "Scalar", "Zeroth (general purpose) Indicator variable", R=0, S=0),
        Field("Iv1", "Scalar", "First (general purpose) Indicator variable", R=0, S=0),
        Field("Iv2", "Scalar", "Second (general purpose) Indicator variable", R=0, S=0),
        Field("Iv3", "Scalar", "Third (general purpose) Indicator variable", R=0, S=0),
        Field("Iv4", "Scalar", "Fourth (general purpose) Indicator variable", R=0, S=0),
        Field("Iv5", "Scalar", "Fifth (general purpose) Indicator variable", R=0, S=0),
        Field("IvLISM", "Scalar", "LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)", R=0, S=0),
        Field("IvBmix", "Scalar", "magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)", R=0, S=0),
        Field("IvSolarCycle", "Scalar", "solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)", R=0, S=0),
    ]
    speciess = [
        Species("PrimitiveGasDyn", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for general gas dynamics"),
        Species("ConservedGasDyn", "Den_t, Mom_t, Enr_t", "Fields of the conserved form for general gas dynamics"),
        Species("PrimitiveMHD", "Den_t, Vel_t, Prs_t, Mag_t, Elc_t", "Fields of the conserved form for general MHD"),
        Species("ConservedMHD", "Den_t, Mom_t, Enr_t, Mag_t, Elc_t", "Fields of the conserved form for general MHD"),
        Species("PrimitiveMHDGLM", "Den_t, Vel_t, Prs_t, Mag_t, Elc_t, Glm_t", "Fields of the conserved form for general MHD-GLM"),
        Species("ConservedMHDGLM", "Den_t, Mom_t, Enr_t, Mag_t, Elc_t, Glm_t", "Fields of the conserved form for general MHD-GLM"),
        Species("ElectronCore", "Den_t, Vel_t, Prs_t, Mag_t, Elc_t, Iv0_t", "Fields of the primitive form for species"),
        Species("ElectronHalo", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("ElectronBeam", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("ProtonCore", "Den_t, Vel_t, Prs_t, Mag_t, Elc_t, Iv0_t", "Fields of the primitive form for species"),
        Species("ProtonHalo", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("ProtonBeam", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("ProtonPickup", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("AlphaCore", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("AlphaHalo", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HeliumSingleCore", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HeliumSinglePickup", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HydrogenPlasmaCore", "Den_t, Vel_t, Prs_t, Mag_t, Glm_t, Iv0_t", "Fields of the primitive form for species"),
        Species("HydrogenCore", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HydrogenHalo", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HydrogenBeam", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
        Species("HeliumCore", "Den_t, Vel_t, Prs_t", "Fields of the primitive form for species"),
    ]

generator = "generate.py"
partially_generated_path = f"../partially_generated/"

def file_header(fname):
    x = f"""/*!
\\file {fname}
\\author Vladimir Florinski
\\author Lucius Schoenbaum
\\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/
"""
    x +=  f"""
/*
This file is automatically generated by {generator}. 
Do not edit this file, instead edit {generator}. 
*/
"""
    return x




def generate_field_lists():
    """
    Generate file `field_lists.hh`.
    """
    fname = "field_lists.hh"
    size = len(fields) + len(speciess)
    field_lists_parts = [
"""
#ifndef SPECTRUM_FIELD_LISTS_HH
#define SPECTRUM_FIELD_LISTS_HH

#include <string_view>
#include <array>

namespace Spectrum::Field {

/*!
Identifiers for distinguished code-wide fields (for lookup).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
enum Id {
anon,
""",
f"""}};

/*!
Formatted names for distinguished code-wide fields
(minimal formatting in ASCII).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
const constexpr std::array<std::string_view, {size+1}> Names = {{
   std::string_view(""),
""",
"""};

// Note: more maps can be added (e.g. unit/scale factor)

}

#endif
""",
    ]
    x = file_header(fname) + field_lists_parts[0]
    for field in fields + speciess:
        x += f"{field.name},\n"
    x += field_lists_parts[1]
    for field in fields + speciess:
        name = field.name if field.printed_name is None else field.printed_name
        x += f'   std::string_view("{name}"),\n'
    x += field_lists_parts[2]
    with open(f"field_lists.hh", 'w') as f:
        f.write(x)





def generate_field_types():
    """
    Generate file `field_types.hh`.
    This file defines the fields as NamedFields classes,
    based on the list `fields`.
    """
    fname = "field_types.hh"
    field_types_parts = [
"""
#ifndef SPECTRUM_FIELD_TYPES_HH
#define SPECTRUM_FIELD_TYPES_HH

#include "../field_structs.hh"

namespace Spectrum {

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + field_types_parts[0]
    for field in fields:
        x += f"/*!\n\\brief {field.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {field.name}_t = {field.fieldtype()}<Field::Id::{field.name}, {field.R}, {field.S}>;\n\n"
    x += field_types_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def generate_species():
    """
    Generate file `species.hh`.
    This file contains types that depend on Species,
    based on the list `species`. Species are accessible in Fields.
    """
    fname = "species_types.hh"
    field_groups_parts = [
f"""
#ifndef SPECTRUM_SPECIES_TYPES_HH
#define SPECTRUM_SPECIES_TYPES_HH

#include "{partially_generated_path}species.hh"

namespace Spectrum {{

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + field_groups_parts[0]
    for grp in speciess:
        x += f"/*!\n\\brief {grp.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {grp.name}_t = Species<Field::Id::{grp.name}, {grp.typelist}>;\n\n"
    x += field_groups_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def inject_fields():
    """
    Works similarly to the other methods, but
    instead of generating the entire file `namedfields.hh` and `fields.hh`,
    it injects into those parts of these files that depend on the generated code.
    These files define the NamedFields and Fields classes.
    The part of those files that is automatically generated is bounded by
    pragmas
    ```
        // BEGIN(fields/generate, <base>)

        ...

        // END(fields/generate, <base>)
    ```
    The files `namedfields.hh` and `fields.hh` should not be modified
    within these pragmas (their contents can be modified by modifying `generate.py`.
    However, outside of them, these files are like any other source code file.
    """
    for level in [0, 1]:
        named = level == 0
        fname = "species.hh" if named else "fields.hh"
        fpath = os_path_join(partially_generated_path, fname)
        with open(fpath, 'r') as f:
            content = f.read()
        injectee_labels = ['class', 'base']
        for injectee_label in injectee_labels:
            label = injectee_label
            pattern = f"\n.*fields/generate,\s*{label}.*\n"
            groups = re_split(pattern, content)
            content = groups[0] + get_injectee(label, named) + groups[2]
        with open(fpath, 'w') as f:
            f.write(content)


def get_injectee(injectee_label, named):
    """

    :param injectee_label: 'base' or 'class'
    :param named: boolean
    """
    fieldlist = fields if named else fields+speciess
    fieldid = "nameid, " if named else ""
    typename = "Species" if named else "Fields"
    x = f"\n   // BEGIN(fields/generate, {injectee_label})\n"
    if injectee_label == 'class':
        for field in fieldlist:
            name = field.name
            description = field.description
            x += f"""
/*!
\\brief Get {name} ({description}) from the data type, as lvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   {name}_t& {name}(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return data;
      else
         return {typename}<{fieldid}Ts...>::{name}();
   }};

/*!
\\brief Get {name} ({description}) from the data type, as const rvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   const {name}_t& {name}(void) const {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return data;
      else
         return {typename}<{fieldid}Ts...>::{name}();
   }};


/*!
\\brief Whether {name} ({description}) is in the data type.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   static constexpr bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return true;
      else
         return {typename}<{fieldid}Ts...>::{name}_found();
   }};
   
"""
    elif injectee_label == 'base':
        for field in fieldlist:
            name = field.name
            description = field.description
            x += f"""
   {name}_t& {name}(void) {{
      try {{
        if constexpr (std::is_same<T, {name}_t>::value)
          return data;
        else
          throw std::invalid_argument( "[{typename}] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }}
      catch (const std::exception& e) {{std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);}};
   }};
   
  const {name}_t& {name}(void) const {{
    try {{
      if constexpr (std::is_same<T, {name}_t>::value)
        return data;
      else
        throw std::invalid_argument( "[{typename}] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }}
    catch (const std::exception& e) {{std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);}};
  }};
   
   static constexpr bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}_t>::value)
         return true;
      else
         return false;
   }};
"""
    x += f"\n   // END(fields/generate, {injectee_label})\n"
    return x




if __name__ == '__main__':

    generate_field_lists()
    generate_field_types()
    generate_species()
    inject_fields()


