/*!
\file mhdtuple.hh
\author Vladimir Florinski
\author Lucius Schoenbaum
\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/

/*
This file contains a block of code generated by generate.py.
Do not edit the contents of this file within the block bounded by
the pragmas "BEGIN(fields/generate)" and "END(fields/generate)",
instead edit the file `generated/generate.py`.
Elsewhere, this file can be edited normally.
*/

#ifndef SPECTRUM_FIELDS_HH
#define SPECTRUM_FIELDS_HH

#include <iostream>
#include <any>
#include <stdexcept>
#include "../generated/species_types.hh"

namespace Spectrum {

/*!
\brief Multi-purpose class storing physical data defined at a spatial location.
Used in the data interface with the (pseudo-)particle tracer, and to house
data distributed on the grid.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note Recursion in protected methods takes place only once, at compile time.
*/
template <typename T, typename ... Ts>
struct Fields: public Fields<Ts...> {

protected:

   T data;

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
\note Public access via visit()
*/
   template <typename Function>
   void visit_unpacked(std::size_t index, Function&& f, auto&&... others) {
      if (index == 0) {
         f(data, others.data...);
      } else {
         Fields<Ts...>::visit_unpacked(index - 1, std::forward<Function>(f), static_cast<Fields<Ts...>>(others)...);
      }
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
\note Public access via foreach()
*/
   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
      Fields<Ts...>::foreach_unpacked(std::forward<Function>(f), static_cast<Fields<Ts...>>(others)...);
   }


/*!
\brief Assignment if types match, otherwise take no action (private helper used by store method).
\author Lucius Schoenbaum
\date 06/25/2025
\param[in] x1, x2 possibly mismatched value/variable instances
*/
   template <typename T1, typename T2>
   void assign(T1& x1, const T2& x2) {
      if constexpr (std::is_same<T1, T2>::value) {
         x1 = x2;
      }
   }

public:

   Fields(void) = default;

   explicit Fields(T in, Ts... rest):
      Fields<Ts...>(rest...),
       data(in)
   {};


/*!
\author Lucius Schoenbaum
\author Vladimir Florinski
\date 07/02/2024
\param[in] other Structure to copy from
\return Reference to the object
*/
   Fields& operator=(const Fields& other) {
      Fields<Ts...>::operator=(other);
      data = other.data;
      return *this;
   };
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return size of tuple
*/
   static size_t size() {
      return sizeof...(Ts)+1;
   }
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return constant reference to top element of tuple
*/
   const T& top() const {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return reference to top element of tuple
*/
   T& top() {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] index index into tuple
\return Reference to member of tuple evaluated at runtime
\note Type of return value must be known (and any_cast to) by caller. 
If this is not the case, use get<index>(fields).
*/
   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         return Fields<Ts...>::operator[](index-1);
   }



/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void visit(std::size_t index, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(index, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] f Function to evaluate on each tuple member
\return Reference to the object
*/
   template <typename Function>
   void foreach(Function&& f) {
      f(data);
      Fields<Ts...>::foreach(f);
   }

/*!
\brief Store a quantity by type
\author Lucius Schoenbaum
\date 06/25/2025
\param[in] x Quantity to store
Note: This method is functionally invalid if the tuple
contains multiple members with the same data type.
This should not occur in fluid or MHD applications.
 */
   template <typename T_store>
   void store(T_store x) {
      assign(data, x);
      Fields<Ts...>::store(x);
   }

/*!
\brief Get a quantity by type
\author Lucius Schoenbaum
\date 08/10/2025
Note: This method is functionally invalid if the tuple
contains multiple members with the same data type.
This should not occur in fluid or MHD applications.
 */
 // TODO: not functional yet
   template <typename T_get>
   T_get get() {
      if constexpr (std::is_same<T, T_get>::value)
         return data;
      else
         return Fields<Ts...>::get();
   }

   // BEGIN(fields/generate, class)

/*!
\brief Get Pos (Position in space) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Pos_t& Pos(void) {
      if constexpr (std::is_same<T, Pos_t>::value)
         return data;
      else
         return Fields<Ts...>::Pos();
   };

/*!
\brief Get Pos (Position in space) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Pos_t& Pos(void) const {
      if constexpr (std::is_same<T, Pos_t>::value)
         return data;
      else
         return Fields<Ts...>::Pos();
   };


/*!
\brief Whether Pos (Position in space) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Pos_found(void) {
      if constexpr (std::is_same<T, Pos_t>::value)
         return true;
      else
         return Fields<Ts...>::Pos_found();
   };
   

/*!
\brief Get Time (Time) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Time_t& Time(void) {
      if constexpr (std::is_same<T, Time_t>::value)
         return data;
      else
         return Fields<Ts...>::Time();
   };

/*!
\brief Get Time (Time) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Time_t& Time(void) const {
      if constexpr (std::is_same<T, Time_t>::value)
         return data;
      else
         return Fields<Ts...>::Time();
   };


/*!
\brief Whether Time (Time) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Time_found(void) {
      if constexpr (std::is_same<T, Time_t>::value)
         return true;
      else
         return Fields<Ts...>::Time_found();
   };
   

/*!
\brief Get Den (Density field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Den_t& Den(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return data;
      else
         return Fields<Ts...>::Den();
   };

/*!
\brief Get Den (Density field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Den_t& Den(void) const {
      if constexpr (std::is_same<T, Den_t>::value)
         return data;
      else
         return Fields<Ts...>::Den();
   };


/*!
\brief Whether Den (Density field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Den_found(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return true;
      else
         return Fields<Ts...>::Den_found();
   };
   

/*!
\brief Get Prs (Pressure field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Prs_t& Prs(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return data;
      else
         return Fields<Ts...>::Prs();
   };

/*!
\brief Get Prs (Pressure field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Prs_t& Prs(void) const {
      if constexpr (std::is_same<T, Prs_t>::value)
         return data;
      else
         return Fields<Ts...>::Prs();
   };


/*!
\brief Whether Prs (Pressure field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Prs_found(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return true;
      else
         return Fields<Ts...>::Prs_found();
   };
   

/*!
\brief Get Enr (Energy field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Enr_t& Enr(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return data;
      else
         return Fields<Ts...>::Enr();
   };

/*!
\brief Get Enr (Energy field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Enr_t& Enr(void) const {
      if constexpr (std::is_same<T, Enr_t>::value)
         return data;
      else
         return Fields<Ts...>::Enr();
   };


/*!
\brief Whether Enr (Energy field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Enr_found(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return true;
      else
         return Fields<Ts...>::Enr_found();
   };
   

/*!
\brief Get Vel (Velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Vel_t& Vel(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return data;
      else
         return Fields<Ts...>::Vel();
   };

/*!
\brief Get Vel (Velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Vel_t& Vel(void) const {
      if constexpr (std::is_same<T, Vel_t>::value)
         return data;
      else
         return Fields<Ts...>::Vel();
   };


/*!
\brief Whether Vel (Velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Vel_found(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return true;
      else
         return Fields<Ts...>::Vel_found();
   };
   

/*!
\brief Get Mom (Momentum field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Mom_t& Mom(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return data;
      else
         return Fields<Ts...>::Mom();
   };

/*!
\brief Get Mom (Momentum field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Mom_t& Mom(void) const {
      if constexpr (std::is_same<T, Mom_t>::value)
         return data;
      else
         return Fields<Ts...>::Mom();
   };


/*!
\brief Whether Mom (Momentum field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Mom_found(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return true;
      else
         return Fields<Ts...>::Mom_found();
   };
   

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxDen_t& FlxDen(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxDen();
   };

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxDen_t& FlxDen(void) const {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxDen();
   };


/*!
\brief Whether FlxDen (Fluid density flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxDen_found(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return true;
      else
         return Fields<Ts...>::FlxDen_found();
   };
   

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxMom_t& FlxMom(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxMom();
   };

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxMom_t& FlxMom(void) const {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxMom();
   };


/*!
\brief Whether FlxMom (Fluid momentum flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxMom_found(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return true;
      else
         return Fields<Ts...>::FlxMom_found();
   };
   

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxEnr_t& FlxEnr(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxEnr();
   };

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxEnr_t& FlxEnr(void) const {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxEnr();
   };


/*!
\brief Whether FlxEnr (Fluid energy flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxEnr_found(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return true;
      else
         return Fields<Ts...>::FlxEnr_found();
   };
   

/*!
\brief Get Mag (Magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Mag_t& Mag(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return data;
      else
         return Fields<Ts...>::Mag();
   };

/*!
\brief Get Mag (Magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Mag_t& Mag(void) const {
      if constexpr (std::is_same<T, Mag_t>::value)
         return data;
      else
         return Fields<Ts...>::Mag();
   };


/*!
\brief Whether Mag (Magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Mag_found(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return true;
      else
         return Fields<Ts...>::Mag_found();
   };
   

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxMag_t& FlxMag(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxMag();
   };

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxMag_t& FlxMag(void) const {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxMag();
   };


/*!
\brief Whether FlxMag (Magnetic field flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxMag_found(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return true;
      else
         return Fields<Ts...>::FlxMag_found();
   };
   

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Glm_t& Glm(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return data;
      else
         return Fields<Ts...>::Glm();
   };

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Glm_t& Glm(void) const {
      if constexpr (std::is_same<T, Glm_t>::value)
         return data;
      else
         return Fields<Ts...>::Glm();
   };


/*!
\brief Whether Glm (Lagrange multiplier field of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Glm_found(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return true;
      else
         return Fields<Ts...>::Glm_found();
   };
   

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxGlm_t& FlxGlm(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxGlm();
   };

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxGlm_t& FlxGlm(void) const {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return data;
      else
         return Fields<Ts...>::FlxGlm();
   };


/*!
\brief Whether FlxGlm (Lagrange mutlipler flux function of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxGlm_found(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return true;
      else
         return Fields<Ts...>::FlxGlm_found();
   };
   

/*!
\brief Get Elc (Electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Elc_t& Elc(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return data;
      else
         return Fields<Ts...>::Elc();
   };

/*!
\brief Get Elc (Electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Elc_t& Elc(void) const {
      if constexpr (std::is_same<T, Elc_t>::value)
         return data;
      else
         return Fields<Ts...>::Elc();
   };


/*!
\brief Whether Elc (Electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Elc_found(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return true;
      else
         return Fields<Ts...>::Elc_found();
   };
   

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   AbsMag_t& AbsMag(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::AbsMag();
   };

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const AbsMag_t& AbsMag(void) const {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::AbsMag();
   };


/*!
\brief Whether AbsMag (Magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool AbsMag_found(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return true;
      else
         return Fields<Ts...>::AbsMag_found();
   };
   

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HatMag_t& HatMag(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::HatMag();
   };

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HatMag_t& HatMag(void) const {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::HatMag();
   };


/*!
\brief Whether HatMag (Magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HatMag_found(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return true;
      else
         return Fields<Ts...>::HatMag_found();
   };
   

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelVel_t& DelVel(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return data;
      else
         return Fields<Ts...>::DelVel();
   };

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelVel_t& DelVel(void) const {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return data;
      else
         return Fields<Ts...>::DelVel();
   };


/*!
\brief Whether DelVel (Gradient of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelVel_found(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return true;
      else
         return Fields<Ts...>::DelVel_found();
   };
   

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelElc_t& DelElc(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return data;
      else
         return Fields<Ts...>::DelElc();
   };

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelElc_t& DelElc(void) const {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return data;
      else
         return Fields<Ts...>::DelElc();
   };


/*!
\brief Whether DelElc (Gradient of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelElc_found(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return true;
      else
         return Fields<Ts...>::DelElc_found();
   };
   

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelMag_t& DelMag(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelMag();
   };

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelMag_t& DelMag(void) const {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelMag();
   };


/*!
\brief Whether DelMag (Gradient of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelMag_found(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DelMag_found();
   };
   

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelAbsMag_t& DelAbsMag(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelAbsMag();
   };

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelAbsMag_t& DelAbsMag(void) const {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelAbsMag();
   };


/*!
\brief Whether DelAbsMag (Gradient of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelAbsMag_found(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DelAbsMag_found();
   };
   

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelHatMag_t& DelHatMag(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelHatMag();
   };

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelHatMag_t& DelHatMag(void) const {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DelHatMag();
   };


/*!
\brief Whether DelHatMag (Gradient of magnetic field direction ) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelHatMag_found(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DelHatMag_found();
   };
   

/*!
\brief Get DdtVel (Time derivative of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DdtVel_t& DdtVel(void) {
      if constexpr (std::is_same<T, DdtVel_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtVel();
   };

/*!
\brief Get DdtVel (Time derivative of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DdtVel_t& DdtVel(void) const {
      if constexpr (std::is_same<T, DdtVel_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtVel();
   };


/*!
\brief Whether DdtVel (Time derivative of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DdtVel_found(void) {
      if constexpr (std::is_same<T, DdtVel_t>::value)
         return true;
      else
         return Fields<Ts...>::DdtVel_found();
   };
   

/*!
\brief Get DdtElc (Time derivative of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DdtElc_t& DdtElc(void) {
      if constexpr (std::is_same<T, DdtElc_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtElc();
   };

/*!
\brief Get DdtElc (Time derivative of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DdtElc_t& DdtElc(void) const {
      if constexpr (std::is_same<T, DdtElc_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtElc();
   };


/*!
\brief Whether DdtElc (Time derivative of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DdtElc_found(void) {
      if constexpr (std::is_same<T, DdtElc_t>::value)
         return true;
      else
         return Fields<Ts...>::DdtElc_found();
   };
   

/*!
\brief Get DdtMag (Time derivative of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DdtMag_t& DdtMag(void) {
      if constexpr (std::is_same<T, DdtMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtMag();
   };

/*!
\brief Get DdtMag (Time derivative of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DdtMag_t& DdtMag(void) const {
      if constexpr (std::is_same<T, DdtMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtMag();
   };


/*!
\brief Whether DdtMag (Time derivative of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DdtMag_found(void) {
      if constexpr (std::is_same<T, DdtMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DdtMag_found();
   };
   

/*!
\brief Get DdtAbsMag (Time derivative of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DdtAbsMag_t& DdtAbsMag(void) {
      if constexpr (std::is_same<T, DdtAbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtAbsMag();
   };

/*!
\brief Get DdtAbsMag (Time derivative of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DdtAbsMag_t& DdtAbsMag(void) const {
      if constexpr (std::is_same<T, DdtAbsMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtAbsMag();
   };


/*!
\brief Whether DdtAbsMag (Time derivative of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DdtAbsMag_found(void) {
      if constexpr (std::is_same<T, DdtAbsMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DdtAbsMag_found();
   };
   

/*!
\brief Get DdtHatMag (Time derivative of magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DdtHatMag_t& DdtHatMag(void) {
      if constexpr (std::is_same<T, DdtHatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtHatMag();
   };

/*!
\brief Get DdtHatMag (Time derivative of magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DdtHatMag_t& DdtHatMag(void) const {
      if constexpr (std::is_same<T, DdtHatMag_t>::value)
         return data;
      else
         return Fields<Ts...>::DdtHatMag();
   };


/*!
\brief Whether DdtHatMag (Time derivative of magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DdtHatMag_found(void) {
      if constexpr (std::is_same<T, DdtHatMag_t>::value)
         return true;
      else
         return Fields<Ts...>::DdtHatMag_found();
   };
   

/*!
\brief Get Iv0 (Zeroth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv0_t& Iv0(void) {
      if constexpr (std::is_same<T, Iv0_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv0();
   };

/*!
\brief Get Iv0 (Zeroth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv0_t& Iv0(void) const {
      if constexpr (std::is_same<T, Iv0_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv0();
   };


/*!
\brief Whether Iv0 (Zeroth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv0_found(void) {
      if constexpr (std::is_same<T, Iv0_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv0_found();
   };
   

/*!
\brief Get Iv1 (First (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv1_t& Iv1(void) {
      if constexpr (std::is_same<T, Iv1_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv1();
   };

/*!
\brief Get Iv1 (First (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv1_t& Iv1(void) const {
      if constexpr (std::is_same<T, Iv1_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv1();
   };


/*!
\brief Whether Iv1 (First (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv1_found(void) {
      if constexpr (std::is_same<T, Iv1_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv1_found();
   };
   

/*!
\brief Get Iv2 (Second (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv2_t& Iv2(void) {
      if constexpr (std::is_same<T, Iv2_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv2();
   };

/*!
\brief Get Iv2 (Second (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv2_t& Iv2(void) const {
      if constexpr (std::is_same<T, Iv2_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv2();
   };


/*!
\brief Whether Iv2 (Second (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv2_found(void) {
      if constexpr (std::is_same<T, Iv2_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv2_found();
   };
   

/*!
\brief Get Iv3 (Third (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv3_t& Iv3(void) {
      if constexpr (std::is_same<T, Iv3_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv3();
   };

/*!
\brief Get Iv3 (Third (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv3_t& Iv3(void) const {
      if constexpr (std::is_same<T, Iv3_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv3();
   };


/*!
\brief Whether Iv3 (Third (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv3_found(void) {
      if constexpr (std::is_same<T, Iv3_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv3_found();
   };
   

/*!
\brief Get Iv4 (Fourth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv4_t& Iv4(void) {
      if constexpr (std::is_same<T, Iv4_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv4();
   };

/*!
\brief Get Iv4 (Fourth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv4_t& Iv4(void) const {
      if constexpr (std::is_same<T, Iv4_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv4();
   };


/*!
\brief Whether Iv4 (Fourth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv4_found(void) {
      if constexpr (std::is_same<T, Iv4_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv4_found();
   };
   

/*!
\brief Get Iv5 (Fifth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Iv5_t& Iv5(void) {
      if constexpr (std::is_same<T, Iv5_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv5();
   };

/*!
\brief Get Iv5 (Fifth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Iv5_t& Iv5(void) const {
      if constexpr (std::is_same<T, Iv5_t>::value)
         return data;
      else
         return Fields<Ts...>::Iv5();
   };


/*!
\brief Whether Iv5 (Fifth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv5_found(void) {
      if constexpr (std::is_same<T, Iv5_t>::value)
         return true;
      else
         return Fields<Ts...>::Iv5_found();
   };
   

/*!
\brief Get IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   IvLISM_t& IvLISM(void) {
      if constexpr (std::is_same<T, IvLISM_t>::value)
         return data;
      else
         return Fields<Ts...>::IvLISM();
   };

/*!
\brief Get IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const IvLISM_t& IvLISM(void) const {
      if constexpr (std::is_same<T, IvLISM_t>::value)
         return data;
      else
         return Fields<Ts...>::IvLISM();
   };


/*!
\brief Whether IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvLISM_found(void) {
      if constexpr (std::is_same<T, IvLISM_t>::value)
         return true;
      else
         return Fields<Ts...>::IvLISM_found();
   };
   

/*!
\brief Get IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   IvBmix_t& IvBmix(void) {
      if constexpr (std::is_same<T, IvBmix_t>::value)
         return data;
      else
         return Fields<Ts...>::IvBmix();
   };

/*!
\brief Get IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const IvBmix_t& IvBmix(void) const {
      if constexpr (std::is_same<T, IvBmix_t>::value)
         return data;
      else
         return Fields<Ts...>::IvBmix();
   };


/*!
\brief Whether IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvBmix_found(void) {
      if constexpr (std::is_same<T, IvBmix_t>::value)
         return true;
      else
         return Fields<Ts...>::IvBmix_found();
   };
   

/*!
\brief Get IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   IvSolarCycle_t& IvSolarCycle(void) {
      if constexpr (std::is_same<T, IvSolarCycle_t>::value)
         return data;
      else
         return Fields<Ts...>::IvSolarCycle();
   };

/*!
\brief Get IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const IvSolarCycle_t& IvSolarCycle(void) const {
      if constexpr (std::is_same<T, IvSolarCycle_t>::value)
         return data;
      else
         return Fields<Ts...>::IvSolarCycle();
   };


/*!
\brief Whether IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvSolarCycle_found(void) {
      if constexpr (std::is_same<T, IvSolarCycle_t>::value)
         return true;
      else
         return Fields<Ts...>::IvSolarCycle_found();
   };
   

/*!
\brief Get PrimitiveGasDyn (Fields of the primitive form for general gas dynamics) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveGasDyn_t& PrimitiveGasDyn(void) {
      if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveGasDyn();
   };

/*!
\brief Get PrimitiveGasDyn (Fields of the primitive form for general gas dynamics) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveGasDyn_t& PrimitiveGasDyn(void) const {
      if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveGasDyn();
   };


/*!
\brief Whether PrimitiveGasDyn (Fields of the primitive form for general gas dynamics) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool PrimitiveGasDyn_found(void) {
      if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
         return true;
      else
         return Fields<Ts...>::PrimitiveGasDyn_found();
   };
   

/*!
\brief Get ConservedGasDyn (Fields of the conserved form for general gas dynamics) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedGasDyn_t& ConservedGasDyn(void) {
      if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedGasDyn();
   };

/*!
\brief Get ConservedGasDyn (Fields of the conserved form for general gas dynamics) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedGasDyn_t& ConservedGasDyn(void) const {
      if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedGasDyn();
   };


/*!
\brief Whether ConservedGasDyn (Fields of the conserved form for general gas dynamics) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ConservedGasDyn_found(void) {
      if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
         return true;
      else
         return Fields<Ts...>::ConservedGasDyn_found();
   };
   

/*!
\brief Get PrimitiveMHD (Fields of the conserved form for general MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveMHD_t& PrimitiveMHD(void) {
      if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveMHD();
   };

/*!
\brief Get PrimitiveMHD (Fields of the conserved form for general MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveMHD_t& PrimitiveMHD(void) const {
      if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveMHD();
   };


/*!
\brief Whether PrimitiveMHD (Fields of the conserved form for general MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool PrimitiveMHD_found(void) {
      if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
         return true;
      else
         return Fields<Ts...>::PrimitiveMHD_found();
   };
   

/*!
\brief Get ConservedMHD (Fields of the conserved form for general MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedMHD_t& ConservedMHD(void) {
      if constexpr (std::is_same<T, ConservedMHD_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedMHD();
   };

/*!
\brief Get ConservedMHD (Fields of the conserved form for general MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedMHD_t& ConservedMHD(void) const {
      if constexpr (std::is_same<T, ConservedMHD_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedMHD();
   };


/*!
\brief Whether ConservedMHD (Fields of the conserved form for general MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ConservedMHD_found(void) {
      if constexpr (std::is_same<T, ConservedMHD_t>::value)
         return true;
      else
         return Fields<Ts...>::ConservedMHD_found();
   };
   

/*!
\brief Get PrimitiveMHDGLM (Fields of the conserved form for general MHD-GLM) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveMHDGLM_t& PrimitiveMHDGLM(void) {
      if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveMHDGLM();
   };

/*!
\brief Get PrimitiveMHDGLM (Fields of the conserved form for general MHD-GLM) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveMHDGLM_t& PrimitiveMHDGLM(void) const {
      if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
         return data;
      else
         return Fields<Ts...>::PrimitiveMHDGLM();
   };


/*!
\brief Whether PrimitiveMHDGLM (Fields of the conserved form for general MHD-GLM) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool PrimitiveMHDGLM_found(void) {
      if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
         return true;
      else
         return Fields<Ts...>::PrimitiveMHDGLM_found();
   };
   

/*!
\brief Get ConservedMHDGLM (Fields of the conserved form for general MHD-GLM) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedMHDGLM_t& ConservedMHDGLM(void) {
      if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedMHDGLM();
   };

/*!
\brief Get ConservedMHDGLM (Fields of the conserved form for general MHD-GLM) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedMHDGLM_t& ConservedMHDGLM(void) const {
      if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
         return data;
      else
         return Fields<Ts...>::ConservedMHDGLM();
   };


/*!
\brief Whether ConservedMHDGLM (Fields of the conserved form for general MHD-GLM) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ConservedMHDGLM_found(void) {
      if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
         return true;
      else
         return Fields<Ts...>::ConservedMHDGLM_found();
   };
   

/*!
\brief Get ElectronCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ElectronCore_t& ElectronCore(void) {
      if constexpr (std::is_same<T, ElectronCore_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronCore();
   };

/*!
\brief Get ElectronCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ElectronCore_t& ElectronCore(void) const {
      if constexpr (std::is_same<T, ElectronCore_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronCore();
   };


/*!
\brief Whether ElectronCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ElectronCore_found(void) {
      if constexpr (std::is_same<T, ElectronCore_t>::value)
         return true;
      else
         return Fields<Ts...>::ElectronCore_found();
   };
   

/*!
\brief Get ElectronHalo (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ElectronHalo_t& ElectronHalo(void) {
      if constexpr (std::is_same<T, ElectronHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronHalo();
   };

/*!
\brief Get ElectronHalo (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ElectronHalo_t& ElectronHalo(void) const {
      if constexpr (std::is_same<T, ElectronHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronHalo();
   };


/*!
\brief Whether ElectronHalo (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ElectronHalo_found(void) {
      if constexpr (std::is_same<T, ElectronHalo_t>::value)
         return true;
      else
         return Fields<Ts...>::ElectronHalo_found();
   };
   

/*!
\brief Get ElectronBeam (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ElectronBeam_t& ElectronBeam(void) {
      if constexpr (std::is_same<T, ElectronBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronBeam();
   };

/*!
\brief Get ElectronBeam (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ElectronBeam_t& ElectronBeam(void) const {
      if constexpr (std::is_same<T, ElectronBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::ElectronBeam();
   };


/*!
\brief Whether ElectronBeam (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ElectronBeam_found(void) {
      if constexpr (std::is_same<T, ElectronBeam_t>::value)
         return true;
      else
         return Fields<Ts...>::ElectronBeam_found();
   };
   

/*!
\brief Get ProtonCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ProtonCore_t& ProtonCore(void) {
      if constexpr (std::is_same<T, ProtonCore_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonCore();
   };

/*!
\brief Get ProtonCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ProtonCore_t& ProtonCore(void) const {
      if constexpr (std::is_same<T, ProtonCore_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonCore();
   };


/*!
\brief Whether ProtonCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ProtonCore_found(void) {
      if constexpr (std::is_same<T, ProtonCore_t>::value)
         return true;
      else
         return Fields<Ts...>::ProtonCore_found();
   };
   

/*!
\brief Get ProtonHalo (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ProtonHalo_t& ProtonHalo(void) {
      if constexpr (std::is_same<T, ProtonHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonHalo();
   };

/*!
\brief Get ProtonHalo (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ProtonHalo_t& ProtonHalo(void) const {
      if constexpr (std::is_same<T, ProtonHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonHalo();
   };


/*!
\brief Whether ProtonHalo (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ProtonHalo_found(void) {
      if constexpr (std::is_same<T, ProtonHalo_t>::value)
         return true;
      else
         return Fields<Ts...>::ProtonHalo_found();
   };
   

/*!
\brief Get ProtonBeam (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ProtonBeam_t& ProtonBeam(void) {
      if constexpr (std::is_same<T, ProtonBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonBeam();
   };

/*!
\brief Get ProtonBeam (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ProtonBeam_t& ProtonBeam(void) const {
      if constexpr (std::is_same<T, ProtonBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonBeam();
   };


/*!
\brief Whether ProtonBeam (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ProtonBeam_found(void) {
      if constexpr (std::is_same<T, ProtonBeam_t>::value)
         return true;
      else
         return Fields<Ts...>::ProtonBeam_found();
   };
   

/*!
\brief Get ProtonPickup (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ProtonPickup_t& ProtonPickup(void) {
      if constexpr (std::is_same<T, ProtonPickup_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonPickup();
   };

/*!
\brief Get ProtonPickup (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ProtonPickup_t& ProtonPickup(void) const {
      if constexpr (std::is_same<T, ProtonPickup_t>::value)
         return data;
      else
         return Fields<Ts...>::ProtonPickup();
   };


/*!
\brief Whether ProtonPickup (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool ProtonPickup_found(void) {
      if constexpr (std::is_same<T, ProtonPickup_t>::value)
         return true;
      else
         return Fields<Ts...>::ProtonPickup_found();
   };
   

/*!
\brief Get AlphaCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   AlphaCore_t& AlphaCore(void) {
      if constexpr (std::is_same<T, AlphaCore_t>::value)
         return data;
      else
         return Fields<Ts...>::AlphaCore();
   };

/*!
\brief Get AlphaCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const AlphaCore_t& AlphaCore(void) const {
      if constexpr (std::is_same<T, AlphaCore_t>::value)
         return data;
      else
         return Fields<Ts...>::AlphaCore();
   };


/*!
\brief Whether AlphaCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool AlphaCore_found(void) {
      if constexpr (std::is_same<T, AlphaCore_t>::value)
         return true;
      else
         return Fields<Ts...>::AlphaCore_found();
   };
   

/*!
\brief Get AlphaHalo (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   AlphaHalo_t& AlphaHalo(void) {
      if constexpr (std::is_same<T, AlphaHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::AlphaHalo();
   };

/*!
\brief Get AlphaHalo (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const AlphaHalo_t& AlphaHalo(void) const {
      if constexpr (std::is_same<T, AlphaHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::AlphaHalo();
   };


/*!
\brief Whether AlphaHalo (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool AlphaHalo_found(void) {
      if constexpr (std::is_same<T, AlphaHalo_t>::value)
         return true;
      else
         return Fields<Ts...>::AlphaHalo_found();
   };
   

/*!
\brief Get HeliumSingleCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HeliumSingleCore_t& HeliumSingleCore(void) {
      if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumSingleCore();
   };

/*!
\brief Get HeliumSingleCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HeliumSingleCore_t& HeliumSingleCore(void) const {
      if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumSingleCore();
   };


/*!
\brief Whether HeliumSingleCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HeliumSingleCore_found(void) {
      if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
         return true;
      else
         return Fields<Ts...>::HeliumSingleCore_found();
   };
   

/*!
\brief Get HeliumSinglePickup (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HeliumSinglePickup_t& HeliumSinglePickup(void) {
      if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumSinglePickup();
   };

/*!
\brief Get HeliumSinglePickup (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HeliumSinglePickup_t& HeliumSinglePickup(void) const {
      if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumSinglePickup();
   };


/*!
\brief Whether HeliumSinglePickup (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HeliumSinglePickup_found(void) {
      if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
         return true;
      else
         return Fields<Ts...>::HeliumSinglePickup_found();
   };
   

/*!
\brief Get HydrogenPlasmaCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HydrogenPlasmaCore_t& HydrogenPlasmaCore(void) {
      if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenPlasmaCore();
   };

/*!
\brief Get HydrogenPlasmaCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HydrogenPlasmaCore_t& HydrogenPlasmaCore(void) const {
      if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenPlasmaCore();
   };


/*!
\brief Whether HydrogenPlasmaCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HydrogenPlasmaCore_found(void) {
      if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
         return true;
      else
         return Fields<Ts...>::HydrogenPlasmaCore_found();
   };
   

/*!
\brief Get HydrogenCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HydrogenCore_t& HydrogenCore(void) {
      if constexpr (std::is_same<T, HydrogenCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenCore();
   };

/*!
\brief Get HydrogenCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HydrogenCore_t& HydrogenCore(void) const {
      if constexpr (std::is_same<T, HydrogenCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenCore();
   };


/*!
\brief Whether HydrogenCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HydrogenCore_found(void) {
      if constexpr (std::is_same<T, HydrogenCore_t>::value)
         return true;
      else
         return Fields<Ts...>::HydrogenCore_found();
   };
   

/*!
\brief Get HydrogenHalo (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HydrogenHalo_t& HydrogenHalo(void) {
      if constexpr (std::is_same<T, HydrogenHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenHalo();
   };

/*!
\brief Get HydrogenHalo (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HydrogenHalo_t& HydrogenHalo(void) const {
      if constexpr (std::is_same<T, HydrogenHalo_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenHalo();
   };


/*!
\brief Whether HydrogenHalo (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HydrogenHalo_found(void) {
      if constexpr (std::is_same<T, HydrogenHalo_t>::value)
         return true;
      else
         return Fields<Ts...>::HydrogenHalo_found();
   };
   

/*!
\brief Get HydrogenBeam (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HydrogenBeam_t& HydrogenBeam(void) {
      if constexpr (std::is_same<T, HydrogenBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenBeam();
   };

/*!
\brief Get HydrogenBeam (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HydrogenBeam_t& HydrogenBeam(void) const {
      if constexpr (std::is_same<T, HydrogenBeam_t>::value)
         return data;
      else
         return Fields<Ts...>::HydrogenBeam();
   };


/*!
\brief Whether HydrogenBeam (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HydrogenBeam_found(void) {
      if constexpr (std::is_same<T, HydrogenBeam_t>::value)
         return true;
      else
         return Fields<Ts...>::HydrogenBeam_found();
   };
   

/*!
\brief Get HeliumCore (Fields of the primitive form for species) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HeliumCore_t& HeliumCore(void) {
      if constexpr (std::is_same<T, HeliumCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumCore();
   };

/*!
\brief Get HeliumCore (Fields of the primitive form for species) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HeliumCore_t& HeliumCore(void) const {
      if constexpr (std::is_same<T, HeliumCore_t>::value)
         return data;
      else
         return Fields<Ts...>::HeliumCore();
   };


/*!
\brief Whether HeliumCore (Fields of the primitive form for species) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HeliumCore_found(void) {
      if constexpr (std::is_same<T, HeliumCore_t>::value)
         return true;
      else
         return Fields<Ts...>::HeliumCore_found();
   };
   

   // END(fields/generate, class)

   /*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of U
*/
   inline double divU(void)
   {
      return DelVel().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of B
*/
   inline double divB(void)
   {
      return DelMag().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of E
*/
   inline double divE(void)
   {
      return DelElc().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of U
*/
   inline GeoVector curlU(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelVel();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of B
*/
   inline GeoVector curlB(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelMag();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of E
*/
   inline GeoVector curlE(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelElc();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };



/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Divergence of bhat
\note The formula comes from applying vector identity (7) in the NRL Plasma formulary
*/
   double divbhat()
   {
      auto bhat = DdtMag();
      auto Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      auto Bdiv = divB();
      double x1 = gradBmag * bhat;
      auto x2 = Bdiv - x1;
      auto x3 = x2/Bmag;
      return x3;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Curl of bhat
\note The formula comes from applying vector identity (8) in the NRL Plasma formulary
*/
   GeoVector curlbhat()
   {
      auto bhat = HatMag();
      // todo fix when using auto or MmagT to set type
      double Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      return (curlB() - (gradBmag ^ bhat)) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Gradient of bhat
\note The formula comes from expanding \partial_i bhat_j = d/dx^i (B_j / B)
*/
   GeoMatrix gradbhat()
   {
      auto bhat = HatMag();
      double Bmag = AbsMag();
      auto gradB = DelMag();
      auto gradBmag = DelAbsMag();
      // todo Dyadic can be made static
      GeoMatrix tmp;
      tmp.Dyadic(gradBmag, bhat);
      return (gradB - tmp) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Time derivative of bhat
*/
   GeoVector dbhatdt()
   {
      auto dBvecdt = DdtMag();
      auto dBmagdt = DdtAbsMag();
      auto bhat = HatMag();
      double Bmag = AbsMag();
      return (dBvecdt - (dBmagdt * bhat)) / Bmag;
   };





   /*!
\author Lucius Schoenbaum
\date 05/28/2025
\return string representation of state, for testing purposes
*/
   std::string str(bool recursive = false) const {
      std::string out;
      if (!recursive) out += "{";
      out += data.str() + ", " + Fields<Ts...>::str(true);
      if (!recursive) out += "}";
      return out;
   }

};


/*!
\brief Base for Fields data type construction.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note There is no doxygen documentation for features in this class,
as the information is only relevant to the implementation.
*/
template <typename T>
struct Fields<T> {

protected:

   T data;

   template <typename Function>
   void visit_unpacked(std::size_t i, Function&& f, auto&&... others) {
      if (i == 0)
         f(data, others.data...);
      else
         throw std::out_of_range("[Fields] out of range");
   }

   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
   }

public:

   Fields(void) = default;

   explicit Fields(T in):
       data(in)
   {};

   Fields& operator=(const Fields& other) {
      data = other.data;
      return *this;
   };

   static size_t size() {
      return 1;
   }
  
   const T& top() const {
      return data;
   }

   T& top() {
      return data;
   }

   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         throw std::out_of_range("[Fields] out of range");
   }

   template <typename Function, typename Others>
   void visit(std::size_t i, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(i, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function>
   void foreach(Function&& f) {
      f(data);
   }

   template <typename T_store>
   void store(T_store x) {
      assign(data, x);
   }

   // TODO: not functional yet
   template <typename T_get>
   T_get get() {
      try {
         if constexpr (std::is_same<T, T_get>::value)
            return data;
         else {
            throw std::invalid_argument("[Fields] Type T in caller's get<T> was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type.");
         }
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   }

   // BEGIN(fields/generate, base)

   Pos_t& Pos(void) {
      try {
        if constexpr (std::is_same<T, Pos_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Pos (Position in space) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Pos_t& Pos(void) const {
    try {
      if constexpr (std::is_same<T, Pos_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Pos (Position in space) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Pos_found(void) {
      if constexpr (std::is_same<T, Pos_t>::value)
         return true;
      else
         return false;
   };

   Time_t& Time(void) {
      try {
        if constexpr (std::is_same<T, Time_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Time (Time) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Time_t& Time(void) const {
    try {
      if constexpr (std::is_same<T, Time_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Time (Time) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Time_found(void) {
      if constexpr (std::is_same<T, Time_t>::value)
         return true;
      else
         return false;
   };

   Den_t& Den(void) {
      try {
        if constexpr (std::is_same<T, Den_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Den (Density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Den_t& Den(void) const {
    try {
      if constexpr (std::is_same<T, Den_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Den (Density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Den_found(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return true;
      else
         return false;
   };

   Prs_t& Prs(void) {
      try {
        if constexpr (std::is_same<T, Prs_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Prs (Pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Prs_t& Prs(void) const {
    try {
      if constexpr (std::is_same<T, Prs_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Prs (Pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Prs_found(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return true;
      else
         return false;
   };

   Enr_t& Enr(void) {
      try {
        if constexpr (std::is_same<T, Enr_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Enr (Energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Enr_t& Enr(void) const {
    try {
      if constexpr (std::is_same<T, Enr_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Enr (Energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Enr_found(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return true;
      else
         return false;
   };

   Vel_t& Vel(void) {
      try {
        if constexpr (std::is_same<T, Vel_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Vel (Velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Vel_t& Vel(void) const {
    try {
      if constexpr (std::is_same<T, Vel_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Vel (Velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Vel_found(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return true;
      else
         return false;
   };

   Mom_t& Mom(void) {
      try {
        if constexpr (std::is_same<T, Mom_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Mom (Momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Mom_t& Mom(void) const {
    try {
      if constexpr (std::is_same<T, Mom_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Mom (Momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Mom_found(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return true;
      else
         return false;
   };

   FlxDen_t& FlxDen(void) {
      try {
        if constexpr (std::is_same<T, FlxDen_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] FlxDen (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const FlxDen_t& FlxDen(void) const {
    try {
      if constexpr (std::is_same<T, FlxDen_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] FlxDen (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool FlxDen_found(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return true;
      else
         return false;
   };

   FlxMom_t& FlxMom(void) {
      try {
        if constexpr (std::is_same<T, FlxMom_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] FlxMom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const FlxMom_t& FlxMom(void) const {
    try {
      if constexpr (std::is_same<T, FlxMom_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] FlxMom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool FlxMom_found(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return true;
      else
         return false;
   };

   FlxEnr_t& FlxEnr(void) {
      try {
        if constexpr (std::is_same<T, FlxEnr_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] FlxEnr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const FlxEnr_t& FlxEnr(void) const {
    try {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] FlxEnr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool FlxEnr_found(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return true;
      else
         return false;
   };

   Mag_t& Mag(void) {
      try {
        if constexpr (std::is_same<T, Mag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Mag_t& Mag(void) const {
    try {
      if constexpr (std::is_same<T, Mag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Mag_found(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return true;
      else
         return false;
   };

   FlxMag_t& FlxMag(void) {
      try {
        if constexpr (std::is_same<T, FlxMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] FlxMag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const FlxMag_t& FlxMag(void) const {
    try {
      if constexpr (std::is_same<T, FlxMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] FlxMag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool FlxMag_found(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return true;
      else
         return false;
   };

   Glm_t& Glm(void) {
      try {
        if constexpr (std::is_same<T, Glm_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Glm_t& Glm(void) const {
    try {
      if constexpr (std::is_same<T, Glm_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Glm_found(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return true;
      else
         return false;
   };

   FlxGlm_t& FlxGlm(void) {
      try {
        if constexpr (std::is_same<T, FlxGlm_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] FlxGlm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const FlxGlm_t& FlxGlm(void) const {
    try {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] FlxGlm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool FlxGlm_found(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return true;
      else
         return false;
   };

   Elc_t& Elc(void) {
      try {
        if constexpr (std::is_same<T, Elc_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Elc (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Elc_t& Elc(void) const {
    try {
      if constexpr (std::is_same<T, Elc_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Elc (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Elc_found(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return true;
      else
         return false;
   };

   AbsMag_t& AbsMag(void) {
      try {
        if constexpr (std::is_same<T, AbsMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] AbsMag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const AbsMag_t& AbsMag(void) const {
    try {
      if constexpr (std::is_same<T, AbsMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] AbsMag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool AbsMag_found(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return true;
      else
         return false;
   };

   HatMag_t& HatMag(void) {
      try {
        if constexpr (std::is_same<T, HatMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HatMag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HatMag_t& HatMag(void) const {
    try {
      if constexpr (std::is_same<T, HatMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HatMag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HatMag_found(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return true;
      else
         return false;
   };

   DelVel_t& DelVel(void) {
      try {
        if constexpr (std::is_same<T, DelVel_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DelVel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DelVel_t& DelVel(void) const {
    try {
      if constexpr (std::is_same<T, DelVel_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DelVel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DelVel_found(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return true;
      else
         return false;
   };

   DelElc_t& DelElc(void) {
      try {
        if constexpr (std::is_same<T, DelElc_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DelElc (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DelElc_t& DelElc(void) const {
    try {
      if constexpr (std::is_same<T, DelElc_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DelElc (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DelElc_found(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return true;
      else
         return false;
   };

   DelMag_t& DelMag(void) {
      try {
        if constexpr (std::is_same<T, DelMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DelMag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DelMag_t& DelMag(void) const {
    try {
      if constexpr (std::is_same<T, DelMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DelMag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DelMag_found(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return true;
      else
         return false;
   };

   DelAbsMag_t& DelAbsMag(void) {
      try {
        if constexpr (std::is_same<T, DelAbsMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DelAbsMag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DelAbsMag_t& DelAbsMag(void) const {
    try {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DelAbsMag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DelAbsMag_found(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return true;
      else
         return false;
   };

   DelHatMag_t& DelHatMag(void) {
      try {
        if constexpr (std::is_same<T, DelHatMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DelHatMag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DelHatMag_t& DelHatMag(void) const {
    try {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DelHatMag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DelHatMag_found(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return true;
      else
         return false;
   };

   DdtVel_t& DdtVel(void) {
      try {
        if constexpr (std::is_same<T, DdtVel_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DdtVel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DdtVel_t& DdtVel(void) const {
    try {
      if constexpr (std::is_same<T, DdtVel_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DdtVel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DdtVel_found(void) {
      if constexpr (std::is_same<T, DdtVel_t>::value)
         return true;
      else
         return false;
   };

   DdtElc_t& DdtElc(void) {
      try {
        if constexpr (std::is_same<T, DdtElc_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DdtElc (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DdtElc_t& DdtElc(void) const {
    try {
      if constexpr (std::is_same<T, DdtElc_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DdtElc (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DdtElc_found(void) {
      if constexpr (std::is_same<T, DdtElc_t>::value)
         return true;
      else
         return false;
   };

   DdtMag_t& DdtMag(void) {
      try {
        if constexpr (std::is_same<T, DdtMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DdtMag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DdtMag_t& DdtMag(void) const {
    try {
      if constexpr (std::is_same<T, DdtMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DdtMag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DdtMag_found(void) {
      if constexpr (std::is_same<T, DdtMag_t>::value)
         return true;
      else
         return false;
   };

   DdtAbsMag_t& DdtAbsMag(void) {
      try {
        if constexpr (std::is_same<T, DdtAbsMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DdtAbsMag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DdtAbsMag_t& DdtAbsMag(void) const {
    try {
      if constexpr (std::is_same<T, DdtAbsMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DdtAbsMag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DdtAbsMag_found(void) {
      if constexpr (std::is_same<T, DdtAbsMag_t>::value)
         return true;
      else
         return false;
   };

   DdtHatMag_t& DdtHatMag(void) {
      try {
        if constexpr (std::is_same<T, DdtHatMag_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] DdtHatMag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const DdtHatMag_t& DdtHatMag(void) const {
    try {
      if constexpr (std::is_same<T, DdtHatMag_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] DdtHatMag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool DdtHatMag_found(void) {
      if constexpr (std::is_same<T, DdtHatMag_t>::value)
         return true;
      else
         return false;
   };

   Iv0_t& Iv0(void) {
      try {
        if constexpr (std::is_same<T, Iv0_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv0 (Zeroth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv0_t& Iv0(void) const {
    try {
      if constexpr (std::is_same<T, Iv0_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv0 (Zeroth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv0_found(void) {
      if constexpr (std::is_same<T, Iv0_t>::value)
         return true;
      else
         return false;
   };

   Iv1_t& Iv1(void) {
      try {
        if constexpr (std::is_same<T, Iv1_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv1 (First (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv1_t& Iv1(void) const {
    try {
      if constexpr (std::is_same<T, Iv1_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv1 (First (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv1_found(void) {
      if constexpr (std::is_same<T, Iv1_t>::value)
         return true;
      else
         return false;
   };

   Iv2_t& Iv2(void) {
      try {
        if constexpr (std::is_same<T, Iv2_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv2 (Second (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv2_t& Iv2(void) const {
    try {
      if constexpr (std::is_same<T, Iv2_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv2 (Second (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv2_found(void) {
      if constexpr (std::is_same<T, Iv2_t>::value)
         return true;
      else
         return false;
   };

   Iv3_t& Iv3(void) {
      try {
        if constexpr (std::is_same<T, Iv3_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv3 (Third (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv3_t& Iv3(void) const {
    try {
      if constexpr (std::is_same<T, Iv3_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv3 (Third (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv3_found(void) {
      if constexpr (std::is_same<T, Iv3_t>::value)
         return true;
      else
         return false;
   };

   Iv4_t& Iv4(void) {
      try {
        if constexpr (std::is_same<T, Iv4_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv4 (Fourth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv4_t& Iv4(void) const {
    try {
      if constexpr (std::is_same<T, Iv4_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv4 (Fourth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv4_found(void) {
      if constexpr (std::is_same<T, Iv4_t>::value)
         return true;
      else
         return false;
   };

   Iv5_t& Iv5(void) {
      try {
        if constexpr (std::is_same<T, Iv5_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] Iv5 (Fifth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const Iv5_t& Iv5(void) const {
    try {
      if constexpr (std::is_same<T, Iv5_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] Iv5 (Fifth (general purpose) Indicator variable) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool Iv5_found(void) {
      if constexpr (std::is_same<T, Iv5_t>::value)
         return true;
      else
         return false;
   };

   IvLISM_t& IvLISM(void) {
      try {
        if constexpr (std::is_same<T, IvLISM_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const IvLISM_t& IvLISM(void) const {
    try {
      if constexpr (std::is_same<T, IvLISM_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool IvLISM_found(void) {
      if constexpr (std::is_same<T, IvLISM_t>::value)
         return true;
      else
         return false;
   };

   IvBmix_t& IvBmix(void) {
      try {
        if constexpr (std::is_same<T, IvBmix_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const IvBmix_t& IvBmix(void) const {
    try {
      if constexpr (std::is_same<T, IvBmix_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool IvBmix_found(void) {
      if constexpr (std::is_same<T, IvBmix_t>::value)
         return true;
      else
         return false;
   };

   IvSolarCycle_t& IvSolarCycle(void) {
      try {
        if constexpr (std::is_same<T, IvSolarCycle_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const IvSolarCycle_t& IvSolarCycle(void) const {
    try {
      if constexpr (std::is_same<T, IvSolarCycle_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool IvSolarCycle_found(void) {
      if constexpr (std::is_same<T, IvSolarCycle_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveGasDyn_t& PrimitiveGasDyn(void) {
      try {
        if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] PrimitiveGasDyn (Fields of the primitive form for general gas dynamics) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const PrimitiveGasDyn_t& PrimitiveGasDyn(void) const {
    try {
      if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] PrimitiveGasDyn (Fields of the primitive form for general gas dynamics) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool PrimitiveGasDyn_found(void) {
      if constexpr (std::is_same<T, PrimitiveGasDyn_t>::value)
         return true;
      else
         return false;
   };

   ConservedGasDyn_t& ConservedGasDyn(void) {
      try {
        if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ConservedGasDyn (Fields of the conserved form for general gas dynamics) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ConservedGasDyn_t& ConservedGasDyn(void) const {
    try {
      if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ConservedGasDyn (Fields of the conserved form for general gas dynamics) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ConservedGasDyn_found(void) {
      if constexpr (std::is_same<T, ConservedGasDyn_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveMHD_t& PrimitiveMHD(void) {
      try {
        if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] PrimitiveMHD (Fields of the conserved form for general MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const PrimitiveMHD_t& PrimitiveMHD(void) const {
    try {
      if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] PrimitiveMHD (Fields of the conserved form for general MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool PrimitiveMHD_found(void) {
      if constexpr (std::is_same<T, PrimitiveMHD_t>::value)
         return true;
      else
         return false;
   };

   ConservedMHD_t& ConservedMHD(void) {
      try {
        if constexpr (std::is_same<T, ConservedMHD_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ConservedMHD (Fields of the conserved form for general MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ConservedMHD_t& ConservedMHD(void) const {
    try {
      if constexpr (std::is_same<T, ConservedMHD_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ConservedMHD (Fields of the conserved form for general MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ConservedMHD_found(void) {
      if constexpr (std::is_same<T, ConservedMHD_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveMHDGLM_t& PrimitiveMHDGLM(void) {
      try {
        if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] PrimitiveMHDGLM (Fields of the conserved form for general MHD-GLM) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const PrimitiveMHDGLM_t& PrimitiveMHDGLM(void) const {
    try {
      if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] PrimitiveMHDGLM (Fields of the conserved form for general MHD-GLM) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool PrimitiveMHDGLM_found(void) {
      if constexpr (std::is_same<T, PrimitiveMHDGLM_t>::value)
         return true;
      else
         return false;
   };

   ConservedMHDGLM_t& ConservedMHDGLM(void) {
      try {
        if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ConservedMHDGLM (Fields of the conserved form for general MHD-GLM) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ConservedMHDGLM_t& ConservedMHDGLM(void) const {
    try {
      if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ConservedMHDGLM (Fields of the conserved form for general MHD-GLM) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ConservedMHDGLM_found(void) {
      if constexpr (std::is_same<T, ConservedMHDGLM_t>::value)
         return true;
      else
         return false;
   };

   ElectronCore_t& ElectronCore(void) {
      try {
        if constexpr (std::is_same<T, ElectronCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ElectronCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ElectronCore_t& ElectronCore(void) const {
    try {
      if constexpr (std::is_same<T, ElectronCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ElectronCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ElectronCore_found(void) {
      if constexpr (std::is_same<T, ElectronCore_t>::value)
         return true;
      else
         return false;
   };

   ElectronHalo_t& ElectronHalo(void) {
      try {
        if constexpr (std::is_same<T, ElectronHalo_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ElectronHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ElectronHalo_t& ElectronHalo(void) const {
    try {
      if constexpr (std::is_same<T, ElectronHalo_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ElectronHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ElectronHalo_found(void) {
      if constexpr (std::is_same<T, ElectronHalo_t>::value)
         return true;
      else
         return false;
   };

   ElectronBeam_t& ElectronBeam(void) {
      try {
        if constexpr (std::is_same<T, ElectronBeam_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ElectronBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ElectronBeam_t& ElectronBeam(void) const {
    try {
      if constexpr (std::is_same<T, ElectronBeam_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ElectronBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ElectronBeam_found(void) {
      if constexpr (std::is_same<T, ElectronBeam_t>::value)
         return true;
      else
         return false;
   };

   ProtonCore_t& ProtonCore(void) {
      try {
        if constexpr (std::is_same<T, ProtonCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ProtonCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ProtonCore_t& ProtonCore(void) const {
    try {
      if constexpr (std::is_same<T, ProtonCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ProtonCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ProtonCore_found(void) {
      if constexpr (std::is_same<T, ProtonCore_t>::value)
         return true;
      else
         return false;
   };

   ProtonHalo_t& ProtonHalo(void) {
      try {
        if constexpr (std::is_same<T, ProtonHalo_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ProtonHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ProtonHalo_t& ProtonHalo(void) const {
    try {
      if constexpr (std::is_same<T, ProtonHalo_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ProtonHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ProtonHalo_found(void) {
      if constexpr (std::is_same<T, ProtonHalo_t>::value)
         return true;
      else
         return false;
   };

   ProtonBeam_t& ProtonBeam(void) {
      try {
        if constexpr (std::is_same<T, ProtonBeam_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ProtonBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ProtonBeam_t& ProtonBeam(void) const {
    try {
      if constexpr (std::is_same<T, ProtonBeam_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ProtonBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ProtonBeam_found(void) {
      if constexpr (std::is_same<T, ProtonBeam_t>::value)
         return true;
      else
         return false;
   };

   ProtonPickup_t& ProtonPickup(void) {
      try {
        if constexpr (std::is_same<T, ProtonPickup_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] ProtonPickup (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const ProtonPickup_t& ProtonPickup(void) const {
    try {
      if constexpr (std::is_same<T, ProtonPickup_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] ProtonPickup (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool ProtonPickup_found(void) {
      if constexpr (std::is_same<T, ProtonPickup_t>::value)
         return true;
      else
         return false;
   };

   AlphaCore_t& AlphaCore(void) {
      try {
        if constexpr (std::is_same<T, AlphaCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] AlphaCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const AlphaCore_t& AlphaCore(void) const {
    try {
      if constexpr (std::is_same<T, AlphaCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] AlphaCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool AlphaCore_found(void) {
      if constexpr (std::is_same<T, AlphaCore_t>::value)
         return true;
      else
         return false;
   };

   AlphaHalo_t& AlphaHalo(void) {
      try {
        if constexpr (std::is_same<T, AlphaHalo_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] AlphaHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const AlphaHalo_t& AlphaHalo(void) const {
    try {
      if constexpr (std::is_same<T, AlphaHalo_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] AlphaHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool AlphaHalo_found(void) {
      if constexpr (std::is_same<T, AlphaHalo_t>::value)
         return true;
      else
         return false;
   };

   HeliumSingleCore_t& HeliumSingleCore(void) {
      try {
        if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HeliumSingleCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HeliumSingleCore_t& HeliumSingleCore(void) const {
    try {
      if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HeliumSingleCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HeliumSingleCore_found(void) {
      if constexpr (std::is_same<T, HeliumSingleCore_t>::value)
         return true;
      else
         return false;
   };

   HeliumSinglePickup_t& HeliumSinglePickup(void) {
      try {
        if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HeliumSinglePickup (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HeliumSinglePickup_t& HeliumSinglePickup(void) const {
    try {
      if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HeliumSinglePickup (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HeliumSinglePickup_found(void) {
      if constexpr (std::is_same<T, HeliumSinglePickup_t>::value)
         return true;
      else
         return false;
   };

   HydrogenPlasmaCore_t& HydrogenPlasmaCore(void) {
      try {
        if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HydrogenPlasmaCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HydrogenPlasmaCore_t& HydrogenPlasmaCore(void) const {
    try {
      if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HydrogenPlasmaCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HydrogenPlasmaCore_found(void) {
      if constexpr (std::is_same<T, HydrogenPlasmaCore_t>::value)
         return true;
      else
         return false;
   };

   HydrogenCore_t& HydrogenCore(void) {
      try {
        if constexpr (std::is_same<T, HydrogenCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HydrogenCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HydrogenCore_t& HydrogenCore(void) const {
    try {
      if constexpr (std::is_same<T, HydrogenCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HydrogenCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HydrogenCore_found(void) {
      if constexpr (std::is_same<T, HydrogenCore_t>::value)
         return true;
      else
         return false;
   };

   HydrogenHalo_t& HydrogenHalo(void) {
      try {
        if constexpr (std::is_same<T, HydrogenHalo_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HydrogenHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HydrogenHalo_t& HydrogenHalo(void) const {
    try {
      if constexpr (std::is_same<T, HydrogenHalo_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HydrogenHalo (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HydrogenHalo_found(void) {
      if constexpr (std::is_same<T, HydrogenHalo_t>::value)
         return true;
      else
         return false;
   };

   HydrogenBeam_t& HydrogenBeam(void) {
      try {
        if constexpr (std::is_same<T, HydrogenBeam_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HydrogenBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HydrogenBeam_t& HydrogenBeam(void) const {
    try {
      if constexpr (std::is_same<T, HydrogenBeam_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HydrogenBeam (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HydrogenBeam_found(void) {
      if constexpr (std::is_same<T, HydrogenBeam_t>::value)
         return true;
      else
         return false;
   };

   HeliumCore_t& HeliumCore(void) {
      try {
        if constexpr (std::is_same<T, HeliumCore_t>::value)
          return data;
        else
          throw std::invalid_argument( "[Fields] HeliumCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
      }
      catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
   };
   
  const HeliumCore_t& HeliumCore(void) const {
    try {
      if constexpr (std::is_same<T, HeliumCore_t>::value)
        return data;
      else
        throw std::invalid_argument( "[Fields] HeliumCore (Fields of the primitive form for species) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
    }
    catch (const std::exception& e) {std::cerr << e.what() << std::endl; std::exit(EXIT_FAILURE);};
  };
   
   static constexpr bool HeliumCore_found(void) {
      if constexpr (std::is_same<T, HeliumCore_t>::value)
         return true;
      else
         return false;
   };

   // END(fields/generate, base)

   /*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of U
*/
   inline double divU(void)
   {
      return DelVel().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of B
*/
   inline double divB(void)
   {
      return DelMag().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of E
*/
   inline double divE(void)
   {
      return DelElc().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of U
*/
   inline GeoVector curlU(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelVel();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of B
*/
   inline GeoVector curlB(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelMag();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of E
*/
   inline GeoVector curlE(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelElc();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };



/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Divergence of bhat
\note The formula comes from applying vector identity (7) in the NRL Plasma formulary
*/
   double divbhat()
   {
      auto bhat = DdtMag();
      auto Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      auto Bdiv = divB();
      double x1 = gradBmag * bhat;
      auto x2 = Bdiv - x1;
      auto x3 = x2/Bmag;
      return x3;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Curl of bhat
\note The formula comes from applying vector identity (8) in the NRL Plasma formulary
*/
   GeoVector curlbhat()
   {
      auto bhat = HatMag();
      // todo fix when using auto or MmagT to set type
      double Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      return (curlB() - (gradBmag ^ bhat)) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Gradient of bhat
\note The formula comes from expanding \partial_i bhat_j = d/dx^i (B_j / B)
*/
   GeoMatrix gradbhat()
   {
      auto bhat = HatMag();
      double Bmag = AbsMag();
      auto gradB = DelMag();
      auto gradBmag = DelAbsMag();
      // todo Dyadic can be made static
      GeoMatrix tmp;
      tmp.Dyadic(gradBmag, bhat);
      return (gradB - tmp) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Time derivative of bhat
*/
   GeoVector dbhatdt()
   {
      auto dBvecdt = DdtMag();
      auto dBmagdt = DdtAbsMag();
      auto bhat = HatMag();
      double Bmag = AbsMag();
      return (dBvecdt - (dBmagdt * bhat)) / Bmag;
   };



   std::string str(bool recursive = false) const {
      if (recursive)
         return data.str();
      else
         return "{" + data.str() + "}";
   }

};

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup const Fields type
\return The `I`th member of tuple, for template argument integer `I`
 \note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, typename T, typename... Ts>
decltype(auto) get(const Fields<T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I-1>(static_cast<const Fields<Ts...>&>(tup));
}

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup Fields type
\return The `I`th member of tuple, for template argument integer `I`
\note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, typename T, typename... Ts>
decltype(auto) get(Fields<T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I - 1>(static_cast<Fields<Ts...> &>(tup));
}

};

#endif
