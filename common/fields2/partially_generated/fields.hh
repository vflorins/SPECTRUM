/*!
\file fields.hh
\author Vladimir Florinski
\author Lucius Schoenbaum
\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/

/*
This file contains a block of code generated by generate.py.
Do not edit the contents of this file within the block bounded by
the pragmas "BEGIN(fields/generate)" and "END(fields/generate)",
instead edit the file `generated/generate.py`.
Elsewhere, this file can be edited normally.
*/

#ifndef SPECTRUM_FIELDS_HH
#define SPECTRUM_FIELDS_HH

#include <iostream>
#include <any>
#include <stdexcept>
#include "../generated/species_types.hh"

namespace Spectrum {

/*!
\brief Multi-purpose class storing physical data defined at a spatial location.
Can be used for data interface in the (pseudo-)particle tracer,
or to house per-cell data on a grid.
\author Lucius Schoenbaum
\author Vladimir Florinski
\author Juan G Alonzo Guzman
\date 08/26/2025
*/
template <typename ... Ts>
struct Fields {
public:

/*!
\brief Check anonymously for presence of a type in the tuple
\author Lucius Schoenbaum
\date 08/26/2025
 */
   template <typename X>
   static constexpr bool found() {
      return (std::same_as<X, Ts> || ...);
   }

//private:
public: // test

   static constexpr const std::size_t Type_not_found = 1e16;

/*!
\brief The size measured in number of independent scalars (the most natural unit for applications).
\author Lucius Schoenbaum
\date 08/26/2025
 */
   static constexpr std::size_t compute_size() {
      return (sizeof(Ts) + ...)/sizeof(double);
   }

   template <typename X>
   static constexpr std::size_t compute_index() {
      constexpr bool locate[] = {std::same_as<X, Ts>...};
      for (std::size_t i = 0; i < sizeof...(Ts); ++i) {
         if (locate[i]) return i;
      }
      return Type_not_found;
   }

   template<std::size_t... Is>
   static constexpr std::size_t compute_offset_impl(std::index_sequence<Is...>) {
      return (sizeof(std::tuple_element_t<Is, std::tuple<Ts...>>) + ...)/sizeof(double);
   }

   template<typename X>
   static constexpr std::size_t compute_offset() {
      constexpr auto i = compute_index<X>();
      if constexpr (i == 0 || i == Type_not_found) return i;
      else return compute_offset_impl(std::make_index_sequence<i>{});
   }

   static constexpr const std::size_t size_ = compute_size();

   // BEGIN(fields/generate, base)

   static constexpr const std::size_t Pos_offset = compute_offset<Pos_t>();
   static constexpr const std::size_t Time_offset = compute_offset<Time_t>();
   static constexpr const std::size_t Den_offset = compute_offset<Den_t>();
   static constexpr const std::size_t Prs_offset = compute_offset<Prs_t>();
   static constexpr const std::size_t Enr_offset = compute_offset<Enr_t>();
   static constexpr const std::size_t Vel_offset = compute_offset<Vel_t>();
   static constexpr const std::size_t Mom_offset = compute_offset<Mom_t>();
   static constexpr const std::size_t FlxDen_offset = compute_offset<FlxDen_t>();
   static constexpr const std::size_t FlxMom_offset = compute_offset<FlxMom_t>();
   static constexpr const std::size_t FlxEnr_offset = compute_offset<FlxEnr_t>();
   static constexpr const std::size_t Mag_offset = compute_offset<Mag_t>();
   static constexpr const std::size_t FlxMag_offset = compute_offset<FlxMag_t>();
   static constexpr const std::size_t Glm_offset = compute_offset<Glm_t>();
   static constexpr const std::size_t FlxGlm_offset = compute_offset<FlxGlm_t>();
   static constexpr const std::size_t Elc_offset = compute_offset<Elc_t>();
   static constexpr const std::size_t AbsMag_offset = compute_offset<AbsMag_t>();
   static constexpr const std::size_t HatMag_offset = compute_offset<HatMag_t>();
   static constexpr const std::size_t DelVel_offset = compute_offset<DelVel_t>();
   static constexpr const std::size_t DelElc_offset = compute_offset<DelElc_t>();
   static constexpr const std::size_t DelMag_offset = compute_offset<DelMag_t>();
   static constexpr const std::size_t DelAbsMag_offset = compute_offset<DelAbsMag_t>();
   static constexpr const std::size_t DelHatMag_offset = compute_offset<DelHatMag_t>();
   static constexpr const std::size_t DotVel_offset = compute_offset<DotVel_t>();
   static constexpr const std::size_t DotElc_offset = compute_offset<DotElc_t>();
   static constexpr const std::size_t DotMag_offset = compute_offset<DotMag_t>();
   static constexpr const std::size_t DotAbsMag_offset = compute_offset<DotAbsMag_t>();
   static constexpr const std::size_t DotHatMag_offset = compute_offset<DotHatMag_t>();
   static constexpr const std::size_t Iv0_offset = compute_offset<Iv0_t>();
   static constexpr const std::size_t Iv1_offset = compute_offset<Iv1_t>();
   static constexpr const std::size_t Iv2_offset = compute_offset<Iv2_t>();
   static constexpr const std::size_t Iv3_offset = compute_offset<Iv3_t>();
   static constexpr const std::size_t Iv4_offset = compute_offset<Iv4_t>();
   static constexpr const std::size_t Iv5_offset = compute_offset<Iv5_t>();
   static constexpr const std::size_t IvLISM_offset = compute_offset<IvLISM_t>();
   static constexpr const std::size_t IvBmix_offset = compute_offset<IvBmix_t>();
   static constexpr const std::size_t IvSolarCycle_offset = compute_offset<IvSolarCycle_t>();

   // END(fields/generate, base)

protected:

   double data[size_];

public:

   Fields(void) = default;

   explicit Fields(Ts... in):
       data(in...)
   {};


/*!
\author Lucius Schoenbaum
\author Vladimir Florinski
\date 07/02/2024
\param[in] other Structure to copy from
\return Reference to the object
*/
   Fields& operator=(const Fields& other) {
      std::memcpy(data, other.data, size_*sizeof(double));
      return *this;
   };
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return size of data structure, measured in number of independent numerical values.
*/
   static size_t size() {
      return size_;
   }

/*!
\author Lucius Schoenbaum
\date 08/26/2025
\return size of data structure, measured in tuple elements.
*/
   static size_t structured_size() {
      return sizeof...(Ts);
   }

/*!
\author Lucius Schoenbaum
\date 08/26/2025
\return the data structure as a random-access memory block (array).
As an array of double, the size is given by the static member size().
*/
   double* Array() {
      return data;
   }

   // BEGIN(fields/generate, class)

/*!
\brief Get Pos (Position in space) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& Pos(void) {
      return reinterpret_cast<GeoVector&>(*(data + Pos_offset));
   };

/*!
\brief Get Pos (Position in space) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& Pos(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + Pos_offset));
   };


/*!
\brief Whether Pos (Position in space) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Pos_found(void) {
      return (Pos_offset != Type_not_found);
   };
   

/*!
\brief Get Time (Time) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Time(void) {
      return reinterpret_cast<double&>(*(data + Time_offset));
   };

/*!
\brief Get Time (Time) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Time(void) const {
      return reinterpret_cast<const double&>(*(data + Time_offset));
   };


/*!
\brief Whether Time (Time) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Time_found(void) {
      return (Time_offset != Type_not_found);
   };
   

/*!
\brief Get Den (Density field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Den(void) {
      return reinterpret_cast<double&>(*(data + Den_offset));
   };

/*!
\brief Get Den (Density field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Den(void) const {
      return reinterpret_cast<const double&>(*(data + Den_offset));
   };


/*!
\brief Whether Den (Density field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Den_found(void) {
      return (Den_offset != Type_not_found);
   };
   

/*!
\brief Get Prs (Pressure field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Prs(void) {
      return reinterpret_cast<double&>(*(data + Prs_offset));
   };

/*!
\brief Get Prs (Pressure field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Prs(void) const {
      return reinterpret_cast<const double&>(*(data + Prs_offset));
   };


/*!
\brief Whether Prs (Pressure field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Prs_found(void) {
      return (Prs_offset != Type_not_found);
   };
   

/*!
\brief Get Enr (Energy field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Enr(void) {
      return reinterpret_cast<double&>(*(data + Enr_offset));
   };

/*!
\brief Get Enr (Energy field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Enr(void) const {
      return reinterpret_cast<const double&>(*(data + Enr_offset));
   };


/*!
\brief Whether Enr (Energy field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Enr_found(void) {
      return (Enr_offset != Type_not_found);
   };
   

/*!
\brief Get Vel (Velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& Vel(void) {
      return reinterpret_cast<GeoVector&>(*(data + Vel_offset));
   };

/*!
\brief Get Vel (Velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& Vel(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + Vel_offset));
   };


/*!
\brief Whether Vel (Velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Vel_found(void) {
      return (Vel_offset != Type_not_found);
   };
   

/*!
\brief Get Mom (Momentum field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& Mom(void) {
      return reinterpret_cast<GeoVector&>(*(data + Mom_offset));
   };

/*!
\brief Get Mom (Momentum field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& Mom(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + Mom_offset));
   };


/*!
\brief Whether Mom (Momentum field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Mom_found(void) {
      return (Mom_offset != Type_not_found);
   };
   

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& FlxDen(void) {
      return reinterpret_cast<double&>(*(data + FlxDen_offset));
   };

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& FlxDen(void) const {
      return reinterpret_cast<const double&>(*(data + FlxDen_offset));
   };


/*!
\brief Whether FlxDen (Fluid density flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxDen_found(void) {
      return (FlxDen_offset != Type_not_found);
   };
   

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& FlxMom(void) {
      return reinterpret_cast<GeoVector&>(*(data + FlxMom_offset));
   };

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& FlxMom(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + FlxMom_offset));
   };


/*!
\brief Whether FlxMom (Fluid momentum flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxMom_found(void) {
      return (FlxMom_offset != Type_not_found);
   };
   

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& FlxEnr(void) {
      return reinterpret_cast<double&>(*(data + FlxEnr_offset));
   };

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& FlxEnr(void) const {
      return reinterpret_cast<const double&>(*(data + FlxEnr_offset));
   };


/*!
\brief Whether FlxEnr (Fluid energy flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxEnr_found(void) {
      return (FlxEnr_offset != Type_not_found);
   };
   

/*!
\brief Get Mag (Magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& Mag(void) {
      return reinterpret_cast<GeoVector&>(*(data + Mag_offset));
   };

/*!
\brief Get Mag (Magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& Mag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + Mag_offset));
   };


/*!
\brief Whether Mag (Magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Mag_found(void) {
      return (Mag_offset != Type_not_found);
   };
   

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& FlxMag(void) {
      return reinterpret_cast<GeoVector&>(*(data + FlxMag_offset));
   };

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& FlxMag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + FlxMag_offset));
   };


/*!
\brief Whether FlxMag (Magnetic field flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxMag_found(void) {
      return (FlxMag_offset != Type_not_found);
   };
   

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Glm(void) {
      return reinterpret_cast<double&>(*(data + Glm_offset));
   };

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Glm(void) const {
      return reinterpret_cast<const double&>(*(data + Glm_offset));
   };


/*!
\brief Whether Glm (Lagrange multiplier field of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Glm_found(void) {
      return (Glm_offset != Type_not_found);
   };
   

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& FlxGlm(void) {
      return reinterpret_cast<double&>(*(data + FlxGlm_offset));
   };

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& FlxGlm(void) const {
      return reinterpret_cast<const double&>(*(data + FlxGlm_offset));
   };


/*!
\brief Whether FlxGlm (Lagrange mutlipler flux function of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool FlxGlm_found(void) {
      return (FlxGlm_offset != Type_not_found);
   };
   

/*!
\brief Get Elc (Electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& Elc(void) {
      return reinterpret_cast<GeoVector&>(*(data + Elc_offset));
   };

/*!
\brief Get Elc (Electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& Elc(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + Elc_offset));
   };


/*!
\brief Whether Elc (Electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Elc_found(void) {
      return (Elc_offset != Type_not_found);
   };
   

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& AbsMag(void) {
      return reinterpret_cast<double&>(*(data + AbsMag_offset));
   };

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& AbsMag(void) const {
      return reinterpret_cast<const double&>(*(data + AbsMag_offset));
   };


/*!
\brief Whether AbsMag (Magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool AbsMag_found(void) {
      return (AbsMag_offset != Type_not_found);
   };
   

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& HatMag(void) {
      return reinterpret_cast<GeoVector&>(*(data + HatMag_offset));
   };

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& HatMag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + HatMag_offset));
   };


/*!
\brief Whether HatMag (Magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool HatMag_found(void) {
      return (HatMag_offset != Type_not_found);
   };
   

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoMatrix& DelVel(void) {
      return reinterpret_cast<GeoMatrix&>(*(data + DelVel_offset));
   };

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoMatrix& DelVel(void) const {
      return reinterpret_cast<const GeoMatrix&>(*(data + DelVel_offset));
   };


/*!
\brief Whether DelVel (Gradient of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelVel_found(void) {
      return (DelVel_offset != Type_not_found);
   };
   

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoMatrix& DelElc(void) {
      return reinterpret_cast<GeoMatrix&>(*(data + DelElc_offset));
   };

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoMatrix& DelElc(void) const {
      return reinterpret_cast<const GeoMatrix&>(*(data + DelElc_offset));
   };


/*!
\brief Whether DelElc (Gradient of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelElc_found(void) {
      return (DelElc_offset != Type_not_found);
   };
   

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoMatrix& DelMag(void) {
      return reinterpret_cast<GeoMatrix&>(*(data + DelMag_offset));
   };

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoMatrix& DelMag(void) const {
      return reinterpret_cast<const GeoMatrix&>(*(data + DelMag_offset));
   };


/*!
\brief Whether DelMag (Gradient of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelMag_found(void) {
      return (DelMag_offset != Type_not_found);
   };
   

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& DelAbsMag(void) {
      return reinterpret_cast<GeoVector&>(*(data + DelAbsMag_offset));
   };

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& DelAbsMag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + DelAbsMag_offset));
   };


/*!
\brief Whether DelAbsMag (Gradient of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelAbsMag_found(void) {
      return (DelAbsMag_offset != Type_not_found);
   };
   

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoMatrix& DelHatMag(void) {
      return reinterpret_cast<GeoMatrix&>(*(data + DelHatMag_offset));
   };

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoMatrix& DelHatMag(void) const {
      return reinterpret_cast<const GeoMatrix&>(*(data + DelHatMag_offset));
   };


/*!
\brief Whether DelHatMag (Gradient of magnetic field direction ) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DelHatMag_found(void) {
      return (DelHatMag_offset != Type_not_found);
   };
   

/*!
\brief Get DotVel (Time derivative of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& DotVel(void) {
      return reinterpret_cast<GeoVector&>(*(data + DotVel_offset));
   };

/*!
\brief Get DotVel (Time derivative of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& DotVel(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + DotVel_offset));
   };


/*!
\brief Whether DotVel (Time derivative of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DotVel_found(void) {
      return (DotVel_offset != Type_not_found);
   };
   

/*!
\brief Get DotElc (Time derivative of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& DotElc(void) {
      return reinterpret_cast<GeoVector&>(*(data + DotElc_offset));
   };

/*!
\brief Get DotElc (Time derivative of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& DotElc(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + DotElc_offset));
   };


/*!
\brief Whether DotElc (Time derivative of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DotElc_found(void) {
      return (DotElc_offset != Type_not_found);
   };
   

/*!
\brief Get DotMag (Time derivative of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& DotMag(void) {
      return reinterpret_cast<GeoVector&>(*(data + DotMag_offset));
   };

/*!
\brief Get DotMag (Time derivative of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& DotMag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + DotMag_offset));
   };


/*!
\brief Whether DotMag (Time derivative of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DotMag_found(void) {
      return (DotMag_offset != Type_not_found);
   };
   

/*!
\brief Get DotAbsMag (Time derivative of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& DotAbsMag(void) {
      return reinterpret_cast<double&>(*(data + DotAbsMag_offset));
   };

/*!
\brief Get DotAbsMag (Time derivative of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& DotAbsMag(void) const {
      return reinterpret_cast<const double&>(*(data + DotAbsMag_offset));
   };


/*!
\brief Whether DotAbsMag (Time derivative of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DotAbsMag_found(void) {
      return (DotAbsMag_offset != Type_not_found);
   };
   

/*!
\brief Get DotHatMag (Time derivative of magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GeoVector& DotHatMag(void) {
      return reinterpret_cast<GeoVector&>(*(data + DotHatMag_offset));
   };

/*!
\brief Get DotHatMag (Time derivative of magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GeoVector& DotHatMag(void) const {
      return reinterpret_cast<const GeoVector&>(*(data + DotHatMag_offset));
   };


/*!
\brief Whether DotHatMag (Time derivative of magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool DotHatMag_found(void) {
      return (DotHatMag_offset != Type_not_found);
   };
   

/*!
\brief Get Iv0 (Zeroth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv0(void) {
      return reinterpret_cast<double&>(*(data + Iv0_offset));
   };

/*!
\brief Get Iv0 (Zeroth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv0(void) const {
      return reinterpret_cast<const double&>(*(data + Iv0_offset));
   };


/*!
\brief Whether Iv0 (Zeroth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv0_found(void) {
      return (Iv0_offset != Type_not_found);
   };
   

/*!
\brief Get Iv1 (First (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv1(void) {
      return reinterpret_cast<double&>(*(data + Iv1_offset));
   };

/*!
\brief Get Iv1 (First (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv1(void) const {
      return reinterpret_cast<const double&>(*(data + Iv1_offset));
   };


/*!
\brief Whether Iv1 (First (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv1_found(void) {
      return (Iv1_offset != Type_not_found);
   };
   

/*!
\brief Get Iv2 (Second (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv2(void) {
      return reinterpret_cast<double&>(*(data + Iv2_offset));
   };

/*!
\brief Get Iv2 (Second (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv2(void) const {
      return reinterpret_cast<const double&>(*(data + Iv2_offset));
   };


/*!
\brief Whether Iv2 (Second (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv2_found(void) {
      return (Iv2_offset != Type_not_found);
   };
   

/*!
\brief Get Iv3 (Third (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv3(void) {
      return reinterpret_cast<double&>(*(data + Iv3_offset));
   };

/*!
\brief Get Iv3 (Third (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv3(void) const {
      return reinterpret_cast<const double&>(*(data + Iv3_offset));
   };


/*!
\brief Whether Iv3 (Third (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv3_found(void) {
      return (Iv3_offset != Type_not_found);
   };
   

/*!
\brief Get Iv4 (Fourth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv4(void) {
      return reinterpret_cast<double&>(*(data + Iv4_offset));
   };

/*!
\brief Get Iv4 (Fourth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv4(void) const {
      return reinterpret_cast<const double&>(*(data + Iv4_offset));
   };


/*!
\brief Whether Iv4 (Fourth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv4_found(void) {
      return (Iv4_offset != Type_not_found);
   };
   

/*!
\brief Get Iv5 (Fifth (general purpose) Indicator variable) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& Iv5(void) {
      return reinterpret_cast<double&>(*(data + Iv5_offset));
   };

/*!
\brief Get Iv5 (Fifth (general purpose) Indicator variable) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& Iv5(void) const {
      return reinterpret_cast<const double&>(*(data + Iv5_offset));
   };


/*!
\brief Whether Iv5 (Fifth (general purpose) Indicator variable) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool Iv5_found(void) {
      return (Iv5_offset != Type_not_found);
   };
   

/*!
\brief Get IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& IvLISM(void) {
      return reinterpret_cast<double&>(*(data + IvLISM_offset));
   };

/*!
\brief Get IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& IvLISM(void) const {
      return reinterpret_cast<const double&>(*(data + IvLISM_offset));
   };


/*!
\brief Whether IvLISM (LISM Indicator variable for diffusion types (Strauss et al. 2013, Potgeiter et al. 2015)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvLISM_found(void) {
      return (IvLISM_offset != Type_not_found);
   };
   

/*!
\brief Get IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& IvBmix(void) {
      return reinterpret_cast<double&>(*(data + IvBmix_offset));
   };

/*!
\brief Get IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& IvBmix(void) const {
      return reinterpret_cast<const double&>(*(data + IvBmix_offset));
   };


/*!
\brief Whether IvBmix (magnetic mixing indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvBmix_found(void) {
      return (IvBmix_offset != Type_not_found);
   };
   

/*!
\brief Get IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   double& IvSolarCycle(void) {
      return reinterpret_cast<double&>(*(data + IvSolarCycle_offset));
   };

/*!
\brief Get IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const double& IvSolarCycle(void) const {
      return reinterpret_cast<const double&>(*(data + IvSolarCycle_offset));
   };


/*!
\brief Whether IvSolarCycle (solar cycle indicator variable (see DiffusionEmpiricalSOQLTandUNLT)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   static constexpr bool IvSolarCycle_found(void) {
      return (IvSolarCycle_offset != Type_not_found);
   };
   

/*!
\brief Creation of a fields type from another fields type, with unavailable fields populated without exception-handling.
\author Lucius Schoenbaum
\date 9/18/2025
*/
   template <typename ParentFields>
   static inline Fields Get(ParentFields& fields) {
      Fields out;
      if constexpr (Fields::Pos_found()) {
         if constexpr (ParentFields::Pos_found())
            out.Pos() = fields.Pos();
         else
            out.Pos() = Pos_t();
      }
      if constexpr (Fields::Time_found()) {
         if constexpr (ParentFields::Time_found())
            out.Time() = fields.Time();
         else
            out.Time() = Time_t();
      }
      if constexpr (Fields::Den_found()) {
         if constexpr (ParentFields::Den_found())
            out.Den() = fields.Den();
         else
            out.Den() = Den_t();
      }
      if constexpr (Fields::Prs_found()) {
         if constexpr (ParentFields::Prs_found())
            out.Prs() = fields.Prs();
         else
            out.Prs() = Prs_t();
      }
      if constexpr (Fields::Enr_found()) {
         if constexpr (ParentFields::Enr_found())
            out.Enr() = fields.Enr();
         else
            out.Enr() = Enr_t();
      }
      if constexpr (Fields::Vel_found()) {
         if constexpr (ParentFields::Vel_found())
            out.Vel() = fields.Vel();
         else
            out.Vel() = Vel_t();
      }
      if constexpr (Fields::Mom_found()) {
         if constexpr (ParentFields::Mom_found())
            out.Mom() = fields.Mom();
         else
            out.Mom() = Mom_t();
      }
      if constexpr (Fields::FlxDen_found()) {
         if constexpr (ParentFields::FlxDen_found())
            out.FlxDen() = fields.FlxDen();
         else
            out.FlxDen() = FlxDen_t();
      }
      if constexpr (Fields::FlxMom_found()) {
         if constexpr (ParentFields::FlxMom_found())
            out.FlxMom() = fields.FlxMom();
         else
            out.FlxMom() = FlxMom_t();
      }
      if constexpr (Fields::FlxEnr_found()) {
         if constexpr (ParentFields::FlxEnr_found())
            out.FlxEnr() = fields.FlxEnr();
         else
            out.FlxEnr() = FlxEnr_t();
      }
      if constexpr (Fields::Mag_found()) {
         if constexpr (ParentFields::Mag_found())
            out.Mag() = fields.Mag();
         else
            out.Mag() = Mag_t();
      }
      if constexpr (Fields::FlxMag_found()) {
         if constexpr (ParentFields::FlxMag_found())
            out.FlxMag() = fields.FlxMag();
         else
            out.FlxMag() = FlxMag_t();
      }
      if constexpr (Fields::Glm_found()) {
         if constexpr (ParentFields::Glm_found())
            out.Glm() = fields.Glm();
         else
            out.Glm() = Glm_t();
      }
      if constexpr (Fields::FlxGlm_found()) {
         if constexpr (ParentFields::FlxGlm_found())
            out.FlxGlm() = fields.FlxGlm();
         else
            out.FlxGlm() = FlxGlm_t();
      }
      if constexpr (Fields::Elc_found()) {
         if constexpr (ParentFields::Elc_found())
            out.Elc() = fields.Elc();
         else
            out.Elc() = Elc_t();
      }
      if constexpr (Fields::AbsMag_found()) {
         if constexpr (ParentFields::AbsMag_found())
            out.AbsMag() = fields.AbsMag();
         else
            out.AbsMag() = AbsMag_t();
      }
      if constexpr (Fields::HatMag_found()) {
         if constexpr (ParentFields::HatMag_found())
            out.HatMag() = fields.HatMag();
         else
            out.HatMag() = HatMag_t();
      }
      if constexpr (Fields::DelVel_found()) {
         if constexpr (ParentFields::DelVel_found())
            out.DelVel() = fields.DelVel();
         else
            out.DelVel() = DelVel_t();
      }
      if constexpr (Fields::DelElc_found()) {
         if constexpr (ParentFields::DelElc_found())
            out.DelElc() = fields.DelElc();
         else
            out.DelElc() = DelElc_t();
      }
      if constexpr (Fields::DelMag_found()) {
         if constexpr (ParentFields::DelMag_found())
            out.DelMag() = fields.DelMag();
         else
            out.DelMag() = DelMag_t();
      }
      if constexpr (Fields::DelAbsMag_found()) {
         if constexpr (ParentFields::DelAbsMag_found())
            out.DelAbsMag() = fields.DelAbsMag();
         else
            out.DelAbsMag() = DelAbsMag_t();
      }
      if constexpr (Fields::DelHatMag_found()) {
         if constexpr (ParentFields::DelHatMag_found())
            out.DelHatMag() = fields.DelHatMag();
         else
            out.DelHatMag() = DelHatMag_t();
      }
      if constexpr (Fields::DotVel_found()) {
         if constexpr (ParentFields::DotVel_found())
            out.DotVel() = fields.DotVel();
         else
            out.DotVel() = DotVel_t();
      }
      if constexpr (Fields::DotElc_found()) {
         if constexpr (ParentFields::DotElc_found())
            out.DotElc() = fields.DotElc();
         else
            out.DotElc() = DotElc_t();
      }
      if constexpr (Fields::DotMag_found()) {
         if constexpr (ParentFields::DotMag_found())
            out.DotMag() = fields.DotMag();
         else
            out.DotMag() = DotMag_t();
      }
      if constexpr (Fields::DotAbsMag_found()) {
         if constexpr (ParentFields::DotAbsMag_found())
            out.DotAbsMag() = fields.DotAbsMag();
         else
            out.DotAbsMag() = DotAbsMag_t();
      }
      if constexpr (Fields::DotHatMag_found()) {
         if constexpr (ParentFields::DotHatMag_found())
            out.DotHatMag() = fields.DotHatMag();
         else
            out.DotHatMag() = DotHatMag_t();
      }
      if constexpr (Fields::Iv0_found()) {
         if constexpr (ParentFields::Iv0_found())
            out.Iv0() = fields.Iv0();
         else
            out.Iv0() = Iv0_t();
      }
      if constexpr (Fields::Iv1_found()) {
         if constexpr (ParentFields::Iv1_found())
            out.Iv1() = fields.Iv1();
         else
            out.Iv1() = Iv1_t();
      }
      if constexpr (Fields::Iv2_found()) {
         if constexpr (ParentFields::Iv2_found())
            out.Iv2() = fields.Iv2();
         else
            out.Iv2() = Iv2_t();
      }
      if constexpr (Fields::Iv3_found()) {
         if constexpr (ParentFields::Iv3_found())
            out.Iv3() = fields.Iv3();
         else
            out.Iv3() = Iv3_t();
      }
      if constexpr (Fields::Iv4_found()) {
         if constexpr (ParentFields::Iv4_found())
            out.Iv4() = fields.Iv4();
         else
            out.Iv4() = Iv4_t();
      }
      if constexpr (Fields::Iv5_found()) {
         if constexpr (ParentFields::Iv5_found())
            out.Iv5() = fields.Iv5();
         else
            out.Iv5() = Iv5_t();
      }
      if constexpr (Fields::IvLISM_found()) {
         if constexpr (ParentFields::IvLISM_found())
            out.IvLISM() = fields.IvLISM();
         else
            out.IvLISM() = IvLISM_t();
      }
      if constexpr (Fields::IvBmix_found()) {
         if constexpr (ParentFields::IvBmix_found())
            out.IvBmix() = fields.IvBmix();
         else
            out.IvBmix() = IvBmix_t();
      }
      if constexpr (Fields::IvSolarCycle_found()) {
         if constexpr (ParentFields::IvSolarCycle_found())
            out.IvSolarCycle() = fields.IvSolarCycle();
         else
            out.IvSolarCycle() = IvSolarCycle_t();
      }
      return out;
   }


   // END(fields/generate, class)





   /*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of U
*/
   inline double divU(void)
   {
      return DelVel().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of B
*/
   inline double divB(void)
   {
      return DelMag().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Divergence of E
*/
   inline double divE(void)
   {
      return DelElc().Trace();
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of U
*/
   inline GeoVector curlU(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelVel();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of B
*/
   inline GeoVector curlB(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelMag();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };

/*!
\author Juan G Alonso Guzman
\date 10/18/2022
\return Curl of E
*/
   inline GeoVector curlE(void)
   {
      GeoVector vec_tmp;
      GeoMatrix G = DelElc();
      vec_tmp[0] = G[1][2] - G[2][1];
      vec_tmp[1] = G[2][0] - G[0][2];
      vec_tmp[2] = G[0][1] - G[1][0];
      return vec_tmp;
   };



/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Divergence of bhat
\note The formula comes from applying vector identity (7) in the NRL Plasma formulary
*/
   double divbhat()
   {
      auto bhat = DotMag();
      auto Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      auto Bdiv = divB();
      double x1 = gradBmag * bhat;
      auto x2 = Bdiv - x1;
      auto x3 = x2/Bmag;
      return x3;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Curl of bhat
\note The formula comes from applying vector identity (8) in the NRL Plasma formulary
*/
   GeoVector curlbhat()
   {
      auto bhat = HatMag();
      double Bmag = AbsMag();
      auto gradBmag = DelAbsMag();
      return (curlB() - (gradBmag ^ bhat)) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Gradient of bhat
\note The formula comes from expanding \partial_i bhat_j = d/dx^i (B_j / B)
*/
   GeoMatrix gradbhat()
   {
      auto bhat = HatMag();
      double Bmag = AbsMag();
      auto gradB = DelMag();
      auto gradBmag = DelAbsMag();
      // todo Dyadic can be made static
      GeoMatrix tmp;
      tmp.Dyadic(gradBmag, bhat);
      return (gradB - tmp) / Bmag;
   };

/*!
\author Juan G Alonso Guzman
\date 07/02/2024
\return Time derivative of bhat
*/
   GeoVector dbhatdt()
   {
      auto dBvecdt = DotMag();
      auto dBmagdt = DotAbsMag();
      auto bhat = HatMag();
      double Bmag = AbsMag();
      return (dBvecdt - (dBmagdt * bhat)) / Bmag;
   };


   /*!
\author Lucius Schoenbaum
\date 05/28/2025
\return string representation of state, for testing purposes
*/
   std::string str(bool recursive = false) const {
      std::string out = "{";
      // todo - foreach
      out += "}";
      return out;
   }

};


};

#endif
