"""
File generate.py Created by Lucius Schoenbaum March 30, 2025
Revised May 26, 2025

A code generator for `MHDtuple`, to facilitate revisions to the set of
formatted variables to be used within SPECTRUM.
This code generator is not intended to be run when SPECTRUM is compiled,
but rather only run whenever the variables and/or associated tools
(all of which is wrapped inside the class MHDtuple) are revised.

Revisions to variables are achieved by modifying the string
arguments to `Variable` and `Tuple` instances in the lists
`variables` and `tuples` (see below), or by adding or subtracting from
these lists. Other revisions to `MHDtuple` are possible by modifying the
generated code in other local areas, as needed.

To run:
In the directory of <this file>:
```shell
python3 <this file>
```

*Notes and Comments*

(1)
A code generator is used because any modification
to the basic set of variables imposes a major and bug-prone update
across multiple zones of the MHDtuple codebase, which (for realistic
lists of variables) is at least two thousand lines of code.
In short, although a code generator is burdensome,
the alternative of managing the files as ordinary source files would
be even more burdensome.

(2)
The files in /variables/ are organized as follows: all source files in the
directory /generate/ are generated by this file, all source files in the
directory /mhdtuple/ are modified (but not generated) by this file,
and files in the directory /variables/ itself are ordinary source code files.

(3)
If it is necessary to edit the files in /mhdtuple/, users may find it convenient
to run `generate.py` with empty lists for `variables` and `groups`,
editing the files, and then re-running generate.py with the desired
lists for `variables` and `groups`. This will make the files in /mhdtuple/
more surveyable and more practical as source files.

"""

from os.path import (
    join as os_path_join
)
from re import (
    split as re_split
)


class Variable:
    """
    A convenience class for expressing the essential
    components of a formatted SPECTRUM variable.
    """

    def __init__(self, name, datatype, description, R, S):
        self.name = name
        self.datatype = datatype
        self.description = description
        self.R = R
        self.S = S

class VariableGroup:
    """
    A convenience class for expressing the essential
    components of a formatted SPECTRUM group of variables.
    """

    def __init__(self, name, typelist, description):
        self.name = name
        self.typelist = typelist
        self.description = description

empty_variable_lists = False
# empty_variable_lists = True

if empty_variable_lists:
    variables = []
    groups = []
else:
    variables = [
        # Fluid variables:
        Variable("den", "Scalar", "Fluid density field", R = 1, S = 0),
        Variable("fden", "Scalar", "Fluid density flux function", R = 1, S = 0),
        Variable("prs", "Scalar", "Fluid pressure field", R = 1, S = 0),
        Variable("enr", "Scalar", "Fluid energy field", R = 1, S = 0),
        Variable("fenr", "Scalar", "Fluid energy flux function", R = 1, S = 0),
        Variable("vel", "GeoVector", "Fluid velocity field", R = 1, S = 0),
        Variable("mom", "GeoVector", "Fluid momentum field", R = 1, S = 0),
        Variable("fmom", "GeoVector", "Fluid momentum flux function", R = 1, S = 0),
        # MHD variables (extending Fluid variables):
        Variable("mag", "GeoVector", "Magnetic field", R = 1, S = 0),
        Variable("fmag", "GeoVector", "Magnetic field flux function", R = 1, S = 0),
        Variable("glm", "Scalar", "Lagrange multiplier field of GLM MHD", R = 1, S = 0),
        Variable("fglm", "Scalar", "Lagrange mutlipler flux function of GLM MHD", R = 1, S = 0),
        # Tracer variables:
        Variable("ele", "GeoVector", "Electric field", R = 1, S = 0),
        Variable("Mmag", "Scalar", "Magnetic field magnitude", R = 1, S = 0),
        Variable("Dmag", "GeoVector", "Magnetic field direction", R = 1, S = 0),
        Variable("Gvel", "GeoMatrix", "Gradient of velocity field", R = 1, S = 0),
        Variable("Gele", "GeoMatrix", "Gradient of electric field", R = 1, S = 0),
        Variable("Gmag", "GeoMatrix", "Gradient of magnetic field", R = 1, S = 0),
        Variable("GMmag", "GeoVector", "Gradient of magnetic field magnitude", R = 1, S = 0),
        Variable("GDmag", "GeoMatrix", "Gradient of magnetic field direction ", R = 1, S = 0),
        Variable("Tvel", "GeoVector", "Time derivative of velocity field", R = 1, S = 0),
        Variable("Tele", "GeoVector", "Time derivative of electric field", R = 1, S = 0),
        Variable("Tmag", "GeoVector", "Time derivative of magnetic field", R = 1, S = 0),
        Variable("TMmag", "Scalar", "Time derivative of magnetic field magnitude", R = 1, S = 0),
        Variable("TDmag", "GeoVector", "Time derivative of magnetic field direction", R = 1, S = 0),
    ]
    groups = [
        # Fluid groups:
        VariableGroup("PrimitiveStateGASDYN", "denT, velT, prsT", "Variables of the primitive form for a gas dynamics model"),
        VariableGroup("ConservedStateGASDYN", "denT, momT, enrT", "Variables of the conserved form for a gas dynamics model"),
        VariableGroup("FluxFunctionGASDYN", "fdenT, fmomT, fenrT", "Variables of the flux function for a gas dynamics model"),
        # MHD groups:
        VariableGroup("PrimitiveStateMHD", "denT, velT, prsT, magT", "Variables of the primitive form for an MHD model"),
        VariableGroup("ConservedStateMHD", "denT, momT, enrT, magT", "Variables of the conserved form for an MHD model"),
        VariableGroup("FluxFunctionMHD", "fdenT, fmomT, fenrT, fmagT", "Variables of the flux function for an MHD model"),
        VariableGroup("PrimitiveStateMHD_GLM", "denT, velT, prsT, magT, glmT", "Variables of the primitive form for an MHD-GLM model"),
        VariableGroup("ConservedStateMHD_GLM", "denT, momT, enrT, magT, glmT", "Variables of the conserved form for an MHD-GLM model"),
        VariableGroup("FluxFunctionMHD_GLM", "fdenT, fmomT, fenrT, fmagT, fglmT", "Variables of the flux function for an MHD-GLM model"),
        # Tracer groups:
        VariableGroup("Bdata", "magT, MmagT, DmagT", "Magnetic field data group"),
        VariableGroup("GBdata", "GmagT, GMmagT, GDmagT", "Magnetic field data group (gradients)"),
        VariableGroup("TBdata", "TmagT, TMmagT, TDmagT", "Magnetic field data group (time derivatives)"),
    ]

generator = "generate.py"
mhdtuple_path = f"../mhdtuple/"

def file_header(fname):
    x = f"""/*!
\\file {fname}
\\author Vladimir Florinski
\\author Lucius Schoenbaum
\\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/
"""
    x +=  f"""
/*
This file is automatically generated by {generator}. 
Do not edit this file, instead edit {generator}. 
*/
"""
    return x




def generate_variable_lists():
    """
    Generate file `variable_lists.hh`.
    """
    fname = "variable_lists.hh"
    size = len(variables) + len(groups)
    variable_lists_parts = [
"""
#ifndef SPECTRUM_VARIABLE_LISTS_HH
#define SPECTRUM_VARIABLE_LISTS_HH

#include <array>

namespace Spectrum {

/*!
Identifiers for distinguished code-wide variables (for lookup).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
enum VariableId {
anon,
""",
f"""}};

/*!
Formatted names for distinguished code-wide variables
(minimal formatting in ASCII).
\\author Lucius Schoenbaum
\\date 03/25/2025
*/
const constexpr std::array<std::string_view, {size+1}> VariableNames = {{
   std::string_view(""),
""",
"""};

// Note: more maps can be added (e.g. unit/scale factor)

}

#endif
""",
    ]
    x = file_header(fname) + variable_lists_parts[0]
    for variable in variables + groups:
        x += f"{variable.name},\n"
    x += variable_lists_parts[1]
    for variable in variables + groups:
        x += f'   std::string_view("{variable.name}"),\n'
    x += variable_lists_parts[2]
    with open(f"variable_lists.hh", 'w') as f:
        f.write(x)





def generate_variable_types():
    """
    Generate file `variable_types.hh`.
    This file defines the variables as NamedMHDtuple classes,
    based on the list `variables`.
    """
    fname = "variable_types.hh"
    variable_types_parts = [
"""
#ifndef SPECTRUM_VARIABLE_TYPES_HH
#define SPECTRUM_VARIABLE_TYPES_HH

#include "../variable_structs.hh"

namespace Spectrum {

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + variable_types_parts[0]
    for variable in variables:
        x += f"/*!\n\\brief {variable.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {variable.name}T = Named{variable.datatype}<VariableId::{variable.name}, {variable.R}, {variable.S}>;\n\n"
    x += variable_types_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def generate_variable_groups():
    """
    Generate file `variable_groups.hh`.
    This file contains types that depend on NamedMHDtuple,
    based on the list `groups`. Groups are accessible in MHDtuples.
    """
    fname = "variable_groups.hh"
    variable_groups_parts = [
f"""
#ifndef SPECTRUM_VARIABLE_GROUPS_HH
#define SPECTRUM_VARIABLE_GROUPS_HH

#include "{mhdtuple_path}namedmhdtuple.hh"

namespace Spectrum {{

""",
"""};

#endif
""",
    ]
    x = file_header(fname) + variable_groups_parts[0]
    for grp in groups:
        x += f"/*!\n\\brief {grp.description} type with a formatted name\n\\author Lucius Schoenbaum\n\\date 03/25/2025\n*/\n"
        x += f"using {grp.name}T = NamedMHDtuple<VariableId::{grp.name}, {grp.typelist}>;\n\n"
    x += variable_groups_parts[1]
    with open(fname, 'w') as f:
        f.write(x)






def inject_mhdtuple():
    """
    Works similarly to the other methods, but
    instead of generating the entire file `namedmhdtuple.hh` and `mhdtuple.hh`,
    it injects into those parts of these files that depend on the generated code.
    These files define the NamedMHDtuple and MHDtuple classes.
    The part of those files that is automatically generated is bounded by
    pragmas
    ```
        // BEGIN(variables/generate, <base>)

        ...

        // END(variables/generate, <base>)
    ```
    The files `namedmhdtuple.hh` and `mhdtuple.hh` should not be modified
    within these pragmas (their contents can be modified by modifying `generate.py`.
    However, outside of them, these files are like any other source code file.
    """
    for level in [0, 1]:
        named = "Named" if level == 0 else ""
        variableid = "nameid, " if level == 0 else ""
        fname = f"{named.lower()}mhdtuple.hh"
        fpath = os_path_join(mhdtuple_path, fname)
        with open(fpath, 'r') as f:
            content = f.read()
        injectee_labels = ['class', 'base']
        for injectee_label in injectee_labels:
            label = injectee_label
            pattern = f"\n.*variables/generate,\s*{label}.*\n"
            groups = re_split(pattern, content)
            content = groups[0] + get_injectee(label, named, variableid) + groups[2]
        with open(fpath, 'w') as f:
            f.write(content)


def get_injectee(injectee_label, named, variableid):
    """

    :param injectee_label: 'base' or 'class'
    :param named:
    :param variableid:
    :return:
    """
    variablelist = variables if named else variables+groups
    x = f"\n   // BEGIN(variables/generate, {injectee_label})\n"
    if injectee_label == 'class':
        for variable in variablelist:
            name = variable.name
            description = variable.description
            x += f"""
/*!
\\brief Get {name} ({description}) from the data type, as lvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   {name}T& {name}(void) {{
      if constexpr (std::is_same<T, {name}T>::value)
         return data;
      else
         return {named}MHDtuple<{variableid}Ts...>::{name}();
   }};

/*!
\\brief Get {name} ({description}) from the data type, as const rvalue.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   const {name}T& {name}(void) const {{
      if constexpr (std::is_same<T, {name}T>::value)
         return data;
      else
         return {named}MHDtuple<{variableid}Ts...>::{name}();
   }};


/*!
\\brief Whether {name} ({description}) is in the data type.
\\author Lucius Schoenbaum
\\date 3/25/2025
*/
   bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}T>::value)
         return true;
      else
         return {named}MHDtuple<{variableid}Ts...>::{name}_found();
   }};
   
"""
    elif injectee_label == 'base':
        for variable in variablelist:
            name = variable.name
            description = variable.description
            x += f"""
   {name}T& {name}(void) {{
      if constexpr (std::is_same<T, {name}T>::value)
         return data;
      else
        throw std::invalid_argument( "[{named}MHDtuple] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   }};
   
  const {name}T& {name}(void) const {{
   if constexpr (std::is_same<T, {name}T>::value)
      return data;
   else
      throw std::invalid_argument( "[{named}MHDtuple] {name} ({description}) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   }};
   
   bool {name}_found(void) {{
      if constexpr (std::is_same<T, {name}T>::value)
         return true;
      else
         return false;
   }};
"""
    x += f"\n   // END(variables/generate, {injectee_label})\n"
    return x




if __name__ == '__main__':

    generate_variable_lists()
    generate_variable_types()
    generate_variable_groups()
    inject_mhdtuple()


