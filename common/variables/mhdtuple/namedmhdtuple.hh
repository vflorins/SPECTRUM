/*!
\file namedmhdtuple.hh
\author Vladimir Florinski
\author Lucius Schoenbaum
\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/

/*
This file contains a block of code generated by generate.py.
Do not edit the contents of this file within the block bounded by
the pragmas "BEGIN(variables/generate)" and "END(variables/generate)",
instead edit the file `variables/generate.py`.
Elsewhere, this file can be edited normally.
*/

#ifndef SPECTRUM_NAMEDMHDTUPLE_HH
#define SPECTRUM_NAMEDMHDTUPLE_HH

#include <iostream>
#include <any>
#include <stdexcept>
#include "../generate/variable_types.hh"

namespace Spectrum {

/*!
\brief Multi-purpose class storing physical data defined at a spatial location.
Used in the data interface with the (pseudo-)particle tracer, and to house
data distributed on the grid.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note Recursion in protected methods takes place only once, at compile time.
*/
template <VariableId nameid, typename T, typename ... Ts>
struct NamedMHDtuple: public NamedMHDtuple<nameid, Ts...> {

protected:

   T data;

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f universal reference function, typically rvalue lambda defined at time of call
\param[in] others variadic universal reference of other tuples having the same tuple type
\note Public access via visit()
*/
   template <typename Function>
   void visit_unpacked(std::size_t index, Function&& f, auto&&... others) {
      if (index == 0) {
         f(data, others.data...);
      } else {
         NamedMHDtuple<nameid, Ts...>::visit_unpacked(index - 1, std::forward<Function>(f), static_cast<NamedMHDtuple<nameid, Ts...>>(others)...);
      }
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f universal reference function, typically rvalue lambda defined at time of call
\param[in] others variadic universal reference of other tuples having the same tuple type
\note Public access via foreach()
*/
   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
      NamedMHDtuple<nameid, Ts...>::foreach_unpacked(std::forward<Function>(f), static_cast<NamedMHDtuple<nameid, Ts...>>(others)...);
   }


/*!
\brief Assignment if types match, otherwise do not compile.
\author Lucius Schoenbaum
\date 06/25/2025
\param[in] x1, x2 possibly mismatched value/variable instances
*/
   template <typename T1, typename T2>
   void assign(T1& x1, const T2& x2) {
      if constexpr (std::is_same<T1, T2>::value) {
         x1 = x2;
      }
   }

public:

   static constexpr const std::string_view name = VariableNames[nameid];

   NamedMHDtuple(void) = default;

   explicit NamedMHDtuple(T in, Ts... rest):
      NamedMHDtuple<nameid, Ts...>(rest...),
       data(in)
   {};


/*!
\author Lucius Schoenbaum
\author Vladimir Florinski
\date 07/02/2024
\param[in] other Structure to copy from
\return Reference to the object
*/
   NamedMHDtuple& operator=(const NamedMHDtuple& other) {
      NamedMHDtuple<nameid, Ts...>::operator=(other);
      data = other.data;
      return *this;
   };
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return size of tuple
*/
   size_t size() const {
      return sizeof...(Ts)+1;
   }
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return constant reference to top element of tuple
*/
   const T& top() const {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return reference to top element of tuple
*/
   T& top() {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] index index into tuple
\return Reference to member of tuple evaluated at runtime
\note Type of return value must be known (and any_cast to) by caller. 
If this is not the case, use get<index>(mhdtuple).
*/
   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::operator[](index-1);
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f universal reference function, typically rvalue lambda defined at time of call
\param[in] others variadic universal reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void visit(std::size_t i, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(i, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }



/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f universal reference function, typically rvalue lambda defined at time of call
\param[in] others variadic universal reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] f Function to evaluate on each tuple member
\return Reference to the object
*/
   template <typename Function>
   void foreach(Function&& f) {
      f(data);
      NamedMHDtuple<nameid, Ts...>::foreach(f);
   }

/*!
\brief Store a quantity by type
\author Lucius Schoenbaum
\date 06/25/2025
\param[in] x Quantity to store
Note: This method is functionally invalid if the tuple
contains multiple members with the same data type.
This should not occur in fluid or MHD applications.
 */
   template <typename T_store>
   void store(T_store x) {
      assign(data, x);
      NamedMHDtuple<nameid, Ts...>::store(x);
   }


   // BEGIN(variables/generate, class)

/*!
\brief Get Den (Fluid density field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Den_t& Den(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Den();
   };

/*!
\brief Get Den (Fluid density field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Den_t& Den(void) const {
      if constexpr (std::is_same<T, Den_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Den();
   };


/*!
\brief Whether Den (Fluid density field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Den_found(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Den_found();
   };
   

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxDen_t& FlxDen(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxDen();
   };

/*!
\brief Get FlxDen (Fluid density flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxDen_t& FlxDen(void) const {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxDen();
   };


/*!
\brief Whether FlxDen (Fluid density flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FlxDen_found(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxDen_found();
   };
   

/*!
\brief Get Prs (Fluid pressure field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Prs_t& Prs(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Prs();
   };

/*!
\brief Get Prs (Fluid pressure field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Prs_t& Prs(void) const {
      if constexpr (std::is_same<T, Prs_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Prs();
   };


/*!
\brief Whether Prs (Fluid pressure field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Prs_found(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Prs_found();
   };
   

/*!
\brief Get Enr (Fluid energy field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Enr_t& Enr(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Enr();
   };

/*!
\brief Get Enr (Fluid energy field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Enr_t& Enr(void) const {
      if constexpr (std::is_same<T, Enr_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Enr();
   };


/*!
\brief Whether Enr (Fluid energy field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Enr_found(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Enr_found();
   };
   

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxEnr_t& FlxEnr(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxEnr();
   };

/*!
\brief Get FlxEnr (Fluid energy flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxEnr_t& FlxEnr(void) const {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxEnr();
   };


/*!
\brief Whether FlxEnr (Fluid energy flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FlxEnr_found(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxEnr_found();
   };
   

/*!
\brief Get Vel (Fluid velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Vel_t& Vel(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Vel();
   };

/*!
\brief Get Vel (Fluid velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Vel_t& Vel(void) const {
      if constexpr (std::is_same<T, Vel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Vel();
   };


/*!
\brief Whether Vel (Fluid velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Vel_found(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Vel_found();
   };
   

/*!
\brief Get Mom (Fluid momentum field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Mom_t& Mom(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Mom();
   };

/*!
\brief Get Mom (Fluid momentum field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Mom_t& Mom(void) const {
      if constexpr (std::is_same<T, Mom_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Mom();
   };


/*!
\brief Whether Mom (Fluid momentum field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Mom_found(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Mom_found();
   };
   

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxMom_t& FlxMom(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMom();
   };

/*!
\brief Get FlxMom (Fluid momentum flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxMom_t& FlxMom(void) const {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMom();
   };


/*!
\brief Whether FlxMom (Fluid momentum flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FlxMom_found(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMom_found();
   };
   

/*!
\brief Get Mag (Magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Mag_t& Mag(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Mag();
   };

/*!
\brief Get Mag (Magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Mag_t& Mag(void) const {
      if constexpr (std::is_same<T, Mag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Mag();
   };


/*!
\brief Whether Mag (Magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Mag_found(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Mag_found();
   };
   

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxMag_t& FlxMag(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMag();
   };

/*!
\brief Get FlxMag (Magnetic field flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxMag_t& FlxMag(void) const {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMag();
   };


/*!
\brief Whether FlxMag (Magnetic field flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FlxMag_found(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxMag_found();
   };
   

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Glm_t& Glm(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Glm();
   };

/*!
\brief Get Glm (Lagrange multiplier field of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Glm_t& Glm(void) const {
      if constexpr (std::is_same<T, Glm_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Glm();
   };


/*!
\brief Whether Glm (Lagrange multiplier field of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Glm_found(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Glm_found();
   };
   

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FlxGlm_t& FlxGlm(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxGlm();
   };

/*!
\brief Get FlxGlm (Lagrange mutlipler flux function of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FlxGlm_t& FlxGlm(void) const {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxGlm();
   };


/*!
\brief Whether FlxGlm (Lagrange mutlipler flux function of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FlxGlm_found(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::FlxGlm_found();
   };
   

/*!
\brief Get Elc (Electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Elc_t& Elc(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Elc();
   };

/*!
\brief Get Elc (Electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Elc_t& Elc(void) const {
      if constexpr (std::is_same<T, Elc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::Elc();
   };


/*!
\brief Whether Elc (Electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Elc_found(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::Elc_found();
   };
   

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   AbsMag_t& AbsMag(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::AbsMag();
   };

/*!
\brief Get AbsMag (Magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const AbsMag_t& AbsMag(void) const {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::AbsMag();
   };


/*!
\brief Whether AbsMag (Magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool AbsMag_found(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::AbsMag_found();
   };
   

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   HatMag_t& HatMag(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::HatMag();
   };

/*!
\brief Get HatMag (Magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const HatMag_t& HatMag(void) const {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::HatMag();
   };


/*!
\brief Whether HatMag (Magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool HatMag_found(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::HatMag_found();
   };
   

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelVel_t& DelVel(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelVel();
   };

/*!
\brief Get DelVel (Gradient of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelVel_t& DelVel(void) const {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelVel();
   };


/*!
\brief Whether DelVel (Gradient of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DelVel_found(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DelVel_found();
   };
   

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelElc_t& DelElc(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelElc();
   };

/*!
\brief Get DelElc (Gradient of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelElc_t& DelElc(void) const {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelElc();
   };


/*!
\brief Whether DelElc (Gradient of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DelElc_found(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DelElc_found();
   };
   

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelMag_t& DelMag(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelMag();
   };

/*!
\brief Get DelMag (Gradient of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelMag_t& DelMag(void) const {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelMag();
   };


/*!
\brief Whether DelMag (Gradient of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DelMag_found(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DelMag_found();
   };
   

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelAbsMag_t& DelAbsMag(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelAbsMag();
   };

/*!
\brief Get DelAbsMag (Gradient of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelAbsMag_t& DelAbsMag(void) const {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelAbsMag();
   };


/*!
\brief Whether DelAbsMag (Gradient of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DelAbsMag_found(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DelAbsMag_found();
   };
   

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DelHatMag_t& DelHatMag(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelHatMag();
   };

/*!
\brief Get DelHatMag (Gradient of magnetic field direction ) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DelHatMag_t& DelHatMag(void) const {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DelHatMag();
   };


/*!
\brief Whether DelHatMag (Gradient of magnetic field direction ) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DelHatMag_found(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DelHatMag_found();
   };
   

/*!
\brief Get DerVel (Time derivative of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DerVel_t& DerVel(void) {
      if constexpr (std::is_same<T, DerVel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerVel();
   };

/*!
\brief Get DerVel (Time derivative of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DerVel_t& DerVel(void) const {
      if constexpr (std::is_same<T, DerVel_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerVel();
   };


/*!
\brief Whether DerVel (Time derivative of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DerVel_found(void) {
      if constexpr (std::is_same<T, DerVel_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DerVel_found();
   };
   

/*!
\brief Get DerElc (Time derivative of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DerElc_t& DerElc(void) {
      if constexpr (std::is_same<T, DerElc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerElc();
   };

/*!
\brief Get DerElc (Time derivative of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DerElc_t& DerElc(void) const {
      if constexpr (std::is_same<T, DerElc_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerElc();
   };


/*!
\brief Whether DerElc (Time derivative of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DerElc_found(void) {
      if constexpr (std::is_same<T, DerElc_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DerElc_found();
   };
   

/*!
\brief Get DerMag (Time derivative of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DerMag_t& DerMag(void) {
      if constexpr (std::is_same<T, DerMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerMag();
   };

/*!
\brief Get DerMag (Time derivative of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DerMag_t& DerMag(void) const {
      if constexpr (std::is_same<T, DerMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerMag();
   };


/*!
\brief Whether DerMag (Time derivative of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DerMag_found(void) {
      if constexpr (std::is_same<T, DerMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DerMag_found();
   };
   

/*!
\brief Get DerAbsMag (Time derivative of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DerAbsMag_t& DerAbsMag(void) {
      if constexpr (std::is_same<T, DerAbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerAbsMag();
   };

/*!
\brief Get DerAbsMag (Time derivative of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DerAbsMag_t& DerAbsMag(void) const {
      if constexpr (std::is_same<T, DerAbsMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerAbsMag();
   };


/*!
\brief Whether DerAbsMag (Time derivative of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DerAbsMag_found(void) {
      if constexpr (std::is_same<T, DerAbsMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DerAbsMag_found();
   };
   

/*!
\brief Get DerHatMag (Time derivative of magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DerHatMag_t& DerHatMag(void) {
      if constexpr (std::is_same<T, DerHatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerHatMag();
   };

/*!
\brief Get DerHatMag (Time derivative of magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DerHatMag_t& DerHatMag(void) const {
      if constexpr (std::is_same<T, DerHatMag_t>::value)
         return data;
      else
         return NamedMHDtuple<nameid, Ts...>::DerHatMag();
   };


/*!
\brief Whether DerHatMag (Time derivative of magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DerHatMag_found(void) {
      if constexpr (std::is_same<T, DerHatMag_t>::value)
         return true;
      else
         return NamedMHDtuple<nameid, Ts...>::DerHatMag_found();
   };
   

   // END(variables/generate, class)


/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return string representation of state, for testing purposes
*/
   std::string str(bool recursive = false) const {
      std::string out;
      if (!recursive) out += std::string(VariableNames[nameid]) + "{";
      out += data.str() + ", " + NamedMHDtuple<nameid, Ts...>::str(true);
      if (!recursive) out += "}";
      return out;
   }

};


/*!
\brief Base for NamedMHDtuple data type construction.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note There is no doxygen documentation for features in this class,
as the information is only relevant to the implementation.
*/
template <VariableId nameid, typename T>
struct NamedMHDtuple<nameid, T> {

protected:

   T data;

   template <typename Function>
   void visit_unpacked(std::size_t index, Function&& f, auto&&... others) {
      if (index == 0)
         f(data, others.data...);
      else
         throw std::out_of_range("[NamedMHDtuple] out of range");
   }

   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
   }

   template <typename T1, typename T2>
   void assign(T1& x1, const T2& x2) {
      if constexpr (std::is_same<T1, T2>::value) {
         x1 = x2;
      }
   }

public:

   static constexpr const std::string_view name = VariableNames[nameid];

   NamedMHDtuple(void) = default;

   explicit NamedMHDtuple(T in):
       data(in)
   {};


   NamedMHDtuple& operator=(const NamedMHDtuple& other) {
      data = other.data;
      return *this;
   };

   size_t size() const {
      return 1;
   }
  
   const T& top() const {
      return data;
   }

   T& top() {
      return data;
   }

   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         throw std::out_of_range("[NamedMHDtuple] out of range");
   }

   template <typename Function, typename Others>
   void visit(std::size_t index, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(index, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function>
   void foreach(Function&& f) {
      f(data);
   }

   template <typename T_store>
   void store(T_store x) {
      assign(data, x);
   }

   // BEGIN(variables/generate, base)

   Den_t& Den(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Den (Fluid density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Den_t& Den(void) const {
   if constexpr (std::is_same<T, Den_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Den (Fluid density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Den_found(void) {
      if constexpr (std::is_same<T, Den_t>::value)
         return true;
      else
         return false;
   };

   FlxDen_t& FlxDen(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] FlxDen (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FlxDen_t& FlxDen(void) const {
   if constexpr (std::is_same<T, FlxDen_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] FlxDen (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FlxDen_found(void) {
      if constexpr (std::is_same<T, FlxDen_t>::value)
         return true;
      else
         return false;
   };

   Prs_t& Prs(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Prs (Fluid pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Prs_t& Prs(void) const {
   if constexpr (std::is_same<T, Prs_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Prs (Fluid pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Prs_found(void) {
      if constexpr (std::is_same<T, Prs_t>::value)
         return true;
      else
         return false;
   };

   Enr_t& Enr(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Enr (Fluid energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Enr_t& Enr(void) const {
   if constexpr (std::is_same<T, Enr_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Enr (Fluid energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Enr_found(void) {
      if constexpr (std::is_same<T, Enr_t>::value)
         return true;
      else
         return false;
   };

   FlxEnr_t& FlxEnr(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] FlxEnr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FlxEnr_t& FlxEnr(void) const {
   if constexpr (std::is_same<T, FlxEnr_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] FlxEnr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FlxEnr_found(void) {
      if constexpr (std::is_same<T, FlxEnr_t>::value)
         return true;
      else
         return false;
   };

   Vel_t& Vel(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Vel (Fluid velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Vel_t& Vel(void) const {
   if constexpr (std::is_same<T, Vel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Vel (Fluid velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Vel_found(void) {
      if constexpr (std::is_same<T, Vel_t>::value)
         return true;
      else
         return false;
   };

   Mom_t& Mom(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Mom (Fluid momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Mom_t& Mom(void) const {
   if constexpr (std::is_same<T, Mom_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Mom (Fluid momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Mom_found(void) {
      if constexpr (std::is_same<T, Mom_t>::value)
         return true;
      else
         return false;
   };

   FlxMom_t& FlxMom(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] FlxMom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FlxMom_t& FlxMom(void) const {
   if constexpr (std::is_same<T, FlxMom_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] FlxMom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FlxMom_found(void) {
      if constexpr (std::is_same<T, FlxMom_t>::value)
         return true;
      else
         return false;
   };

   Mag_t& Mag(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Mag_t& Mag(void) const {
   if constexpr (std::is_same<T, Mag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Mag_found(void) {
      if constexpr (std::is_same<T, Mag_t>::value)
         return true;
      else
         return false;
   };

   FlxMag_t& FlxMag(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] FlxMag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FlxMag_t& FlxMag(void) const {
   if constexpr (std::is_same<T, FlxMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] FlxMag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FlxMag_found(void) {
      if constexpr (std::is_same<T, FlxMag_t>::value)
         return true;
      else
         return false;
   };

   Glm_t& Glm(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Glm_t& Glm(void) const {
   if constexpr (std::is_same<T, Glm_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Glm_found(void) {
      if constexpr (std::is_same<T, Glm_t>::value)
         return true;
      else
         return false;
   };

   FlxGlm_t& FlxGlm(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] FlxGlm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FlxGlm_t& FlxGlm(void) const {
   if constexpr (std::is_same<T, FlxGlm_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] FlxGlm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FlxGlm_found(void) {
      if constexpr (std::is_same<T, FlxGlm_t>::value)
         return true;
      else
         return false;
   };

   Elc_t& Elc(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] Elc (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Elc_t& Elc(void) const {
   if constexpr (std::is_same<T, Elc_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] Elc (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Elc_found(void) {
      if constexpr (std::is_same<T, Elc_t>::value)
         return true;
      else
         return false;
   };

   AbsMag_t& AbsMag(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] AbsMag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const AbsMag_t& AbsMag(void) const {
   if constexpr (std::is_same<T, AbsMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] AbsMag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool AbsMag_found(void) {
      if constexpr (std::is_same<T, AbsMag_t>::value)
         return true;
      else
         return false;
   };

   HatMag_t& HatMag(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] HatMag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const HatMag_t& HatMag(void) const {
   if constexpr (std::is_same<T, HatMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] HatMag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool HatMag_found(void) {
      if constexpr (std::is_same<T, HatMag_t>::value)
         return true;
      else
         return false;
   };

   DelVel_t& DelVel(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DelVel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DelVel_t& DelVel(void) const {
   if constexpr (std::is_same<T, DelVel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DelVel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DelVel_found(void) {
      if constexpr (std::is_same<T, DelVel_t>::value)
         return true;
      else
         return false;
   };

   DelElc_t& DelElc(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DelElc (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DelElc_t& DelElc(void) const {
   if constexpr (std::is_same<T, DelElc_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DelElc (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DelElc_found(void) {
      if constexpr (std::is_same<T, DelElc_t>::value)
         return true;
      else
         return false;
   };

   DelMag_t& DelMag(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DelMag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DelMag_t& DelMag(void) const {
   if constexpr (std::is_same<T, DelMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DelMag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DelMag_found(void) {
      if constexpr (std::is_same<T, DelMag_t>::value)
         return true;
      else
         return false;
   };

   DelAbsMag_t& DelAbsMag(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DelAbsMag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DelAbsMag_t& DelAbsMag(void) const {
   if constexpr (std::is_same<T, DelAbsMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DelAbsMag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DelAbsMag_found(void) {
      if constexpr (std::is_same<T, DelAbsMag_t>::value)
         return true;
      else
         return false;
   };

   DelHatMag_t& DelHatMag(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DelHatMag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DelHatMag_t& DelHatMag(void) const {
   if constexpr (std::is_same<T, DelHatMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DelHatMag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DelHatMag_found(void) {
      if constexpr (std::is_same<T, DelHatMag_t>::value)
         return true;
      else
         return false;
   };

   DerVel_t& DerVel(void) {
      if constexpr (std::is_same<T, DerVel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DerVel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DerVel_t& DerVel(void) const {
   if constexpr (std::is_same<T, DerVel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DerVel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DerVel_found(void) {
      if constexpr (std::is_same<T, DerVel_t>::value)
         return true;
      else
         return false;
   };

   DerElc_t& DerElc(void) {
      if constexpr (std::is_same<T, DerElc_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DerElc (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DerElc_t& DerElc(void) const {
   if constexpr (std::is_same<T, DerElc_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DerElc (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DerElc_found(void) {
      if constexpr (std::is_same<T, DerElc_t>::value)
         return true;
      else
         return false;
   };

   DerMag_t& DerMag(void) {
      if constexpr (std::is_same<T, DerMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DerMag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DerMag_t& DerMag(void) const {
   if constexpr (std::is_same<T, DerMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DerMag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DerMag_found(void) {
      if constexpr (std::is_same<T, DerMag_t>::value)
         return true;
      else
         return false;
   };

   DerAbsMag_t& DerAbsMag(void) {
      if constexpr (std::is_same<T, DerAbsMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DerAbsMag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DerAbsMag_t& DerAbsMag(void) const {
   if constexpr (std::is_same<T, DerAbsMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DerAbsMag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DerAbsMag_found(void) {
      if constexpr (std::is_same<T, DerAbsMag_t>::value)
         return true;
      else
         return false;
   };

   DerHatMag_t& DerHatMag(void) {
      if constexpr (std::is_same<T, DerHatMag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[NamedMHDtuple] DerHatMag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DerHatMag_t& DerHatMag(void) const {
   if constexpr (std::is_same<T, DerHatMag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[NamedMHDtuple] DerHatMag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DerHatMag_found(void) {
      if constexpr (std::is_same<T, DerHatMag_t>::value)
         return true;
      else
         return false;
   };

   // END(variables/generate, base)

   std::string str(bool recursive = false) const {
      if (recursive)
         return data.str();
      else
         return std::string(VariableNames[nameid]) + "{" + data.str() + "}";
   }

};

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup const NamedMHDtuple type
\return The `I`th member of tuple, for template argument integer `I`
 \note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, VariableId nameid, typename T, typename... Ts>
decltype(auto) get(const NamedMHDtuple<nameid, T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I-1>(static_cast<const NamedMHDtuple<nameid, Ts...>&>(tup));
}

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup NamedMHDtuple type
\return The `I`th member of tuple, for template argument integer `I`
\note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, VariableId nameid, typename T, typename... Ts>
decltype(auto) get(NamedMHDtuple<nameid, T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I-1>(static_cast<NamedMHDtuple<nameid, Ts...>&>(tup));
}

};

#endif
