/*!
\file mhdtuple.hh
\author Vladimir Florinski
\author Lucius Schoenbaum
\author Juan G Alonso Guzman

This file is part of the SPECTRUM suite of scientific numerical simulation codes. SPECTRUM stands for Space Plasma and Energetic Charged particle TRansport on Unstructured Meshes. The code simulates plasma or neutral particle flows using MHD equations on a grid, transport of cosmic rays using stochastic or grid based methods. The "unstructured" part refers to the use of a geodesic mesh providing a uniform coverage of the surface of a sphere.
*/

/*
This file contains a block of code generated by generate.py.
Do not edit the contents of this file within the block bounded by
the pragmas "BEGIN(variables/generate)" and "END(variables/generate)",
instead edit the file `variables/generate.py`.
Elsewhere, this file can be edited normally.
*/

#ifndef SPECTRUM_MHDTUPLE_HH
#define SPECTRUM_MHDTUPLE_HH

#include <iostream>
#include <any>
#include <stdexcept>
#include "../generate/variable_groups.hh"

namespace Spectrum {

/*!
\brief Multi-purpose class storing physical data defined at a spatial location.
Used in the data interface with the (pseudo-)particle tracer, and to house
data distributed on the grid.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note Recursion in protected methods takes place only once, at compile time.
*/
template <typename T, typename ... Ts>
struct MHDtuple: public MHDtuple<Ts...> {

protected:

   T data;

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
\note Public access via visit()
*/
   template <typename Function>
   void visit_unpacked(std::size_t index, Function&& f, auto&&... others) {
      if (index == 0) {
         f(data, others.data...);
      } else {
         MHDtuple<Ts...>::visit_unpacked(index - 1, std::forward<Function>(f), static_cast<MHDtuple<Ts...>>(others)...);
      }
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
\note Public access via foreach()
*/
   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
      MHDtuple<Ts...>::foreach_unpacked(std::forward<Function>(f), static_cast<MHDtuple<Ts...>>(others)...);
   }


public:

   MHDtuple(void) = default;

   explicit MHDtuple(T in, Ts... rest):
      MHDtuple<Ts...>(rest...),
       data(in)
   {};


/*!
\author Lucius Schoenbaum
\author Vladimir Florinski
\date 07/02/2024
\param[in] other Structure to copy from
\return Reference to the object
*/
   MHDtuple& operator=(const MHDtuple& other) {
      MHDtuple<Ts...>::operator=(other);
      data = other.data;
      return *this;
   };
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return size of tuple
*/
   size_t size() const {
      return sizeof...(Ts)+1;
   }
  
/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return constant reference to top element of tuple
*/
   const T& top() const {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return reference to top element of tuple
*/
   T& top() {
      return data;
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] index index into tuple
\return Reference to member of tuple evaluated at runtime
\note Type of return value must be known (and any_cast to) by caller. 
If this is not the case, use get<index>(mhdtuple).
*/
   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         return MHDtuple<Ts...>::operator[](index-1);
   }



/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] index index into tuple
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void visit(std::size_t index, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(index, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] f lvalue reference function, i.e., lambda defined at time of call
\param[in] others variadic lvalue reference of other tuples having the same tuple type
*/
   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

/*!
\author Lucius Schoenbaum
\date 05/28/2025
\param[in] f Function to evaluate on each tuple member
\return Reference to the object
*/
   template <typename Function>
   void foreach(Function&& f) {
      f(data);
      MHDtuple<Ts...>::foreach(f);
   }


   // BEGIN(variables/generate, class)

/*!
\brief Get den (Fluid density field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   den_t& den(void) {
      if constexpr (std::is_same<T, den_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::den();
   };

/*!
\brief Get den (Fluid density field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const den_t& den(void) const {
      if constexpr (std::is_same<T, den_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::den();
   };


/*!
\brief Whether den (Fluid density field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool den_found(void) {
      if constexpr (std::is_same<T, den_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::den_found();
   };
   

/*!
\brief Get fden (Fluid density flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   fden_t& fden(void) {
      if constexpr (std::is_same<T, fden_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fden();
   };

/*!
\brief Get fden (Fluid density flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const fden_t& fden(void) const {
      if constexpr (std::is_same<T, fden_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fden();
   };


/*!
\brief Whether fden (Fluid density flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool fden_found(void) {
      if constexpr (std::is_same<T, fden_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::fden_found();
   };
   

/*!
\brief Get prs (Fluid pressure field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   prs_t& prs(void) {
      if constexpr (std::is_same<T, prs_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::prs();
   };

/*!
\brief Get prs (Fluid pressure field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const prs_t& prs(void) const {
      if constexpr (std::is_same<T, prs_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::prs();
   };


/*!
\brief Whether prs (Fluid pressure field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool prs_found(void) {
      if constexpr (std::is_same<T, prs_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::prs_found();
   };
   

/*!
\brief Get enr (Fluid energy field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   enr_t& enr(void) {
      if constexpr (std::is_same<T, enr_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::enr();
   };

/*!
\brief Get enr (Fluid energy field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const enr_t& enr(void) const {
      if constexpr (std::is_same<T, enr_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::enr();
   };


/*!
\brief Whether enr (Fluid energy field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool enr_found(void) {
      if constexpr (std::is_same<T, enr_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::enr_found();
   };
   

/*!
\brief Get fenr (Fluid energy flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   fenr_t& fenr(void) {
      if constexpr (std::is_same<T, fenr_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fenr();
   };

/*!
\brief Get fenr (Fluid energy flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const fenr_t& fenr(void) const {
      if constexpr (std::is_same<T, fenr_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fenr();
   };


/*!
\brief Whether fenr (Fluid energy flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool fenr_found(void) {
      if constexpr (std::is_same<T, fenr_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::fenr_found();
   };
   

/*!
\brief Get vel (Fluid velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   vel_t& vel(void) {
      if constexpr (std::is_same<T, vel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::vel();
   };

/*!
\brief Get vel (Fluid velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const vel_t& vel(void) const {
      if constexpr (std::is_same<T, vel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::vel();
   };


/*!
\brief Whether vel (Fluid velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool vel_found(void) {
      if constexpr (std::is_same<T, vel_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::vel_found();
   };
   

/*!
\brief Get mom (Fluid momentum field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   mom_t& mom(void) {
      if constexpr (std::is_same<T, mom_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::mom();
   };

/*!
\brief Get mom (Fluid momentum field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const mom_t& mom(void) const {
      if constexpr (std::is_same<T, mom_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::mom();
   };


/*!
\brief Whether mom (Fluid momentum field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool mom_found(void) {
      if constexpr (std::is_same<T, mom_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::mom_found();
   };
   

/*!
\brief Get fmom (Fluid momentum flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   fmom_t& fmom(void) {
      if constexpr (std::is_same<T, fmom_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fmom();
   };

/*!
\brief Get fmom (Fluid momentum flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const fmom_t& fmom(void) const {
      if constexpr (std::is_same<T, fmom_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fmom();
   };


/*!
\brief Whether fmom (Fluid momentum flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool fmom_found(void) {
      if constexpr (std::is_same<T, fmom_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::fmom_found();
   };
   

/*!
\brief Get mag (Magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   mag_t& mag(void) {
      if constexpr (std::is_same<T, mag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::mag();
   };

/*!
\brief Get mag (Magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const mag_t& mag(void) const {
      if constexpr (std::is_same<T, mag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::mag();
   };


/*!
\brief Whether mag (Magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool mag_found(void) {
      if constexpr (std::is_same<T, mag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::mag_found();
   };
   

/*!
\brief Get fmag (Magnetic field flux function) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   fmag_t& fmag(void) {
      if constexpr (std::is_same<T, fmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fmag();
   };

/*!
\brief Get fmag (Magnetic field flux function) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const fmag_t& fmag(void) const {
      if constexpr (std::is_same<T, fmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fmag();
   };


/*!
\brief Whether fmag (Magnetic field flux function) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool fmag_found(void) {
      if constexpr (std::is_same<T, fmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::fmag_found();
   };
   

/*!
\brief Get glm (Lagrange multiplier field of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   glm_t& glm(void) {
      if constexpr (std::is_same<T, glm_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::glm();
   };

/*!
\brief Get glm (Lagrange multiplier field of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const glm_t& glm(void) const {
      if constexpr (std::is_same<T, glm_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::glm();
   };


/*!
\brief Whether glm (Lagrange multiplier field of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool glm_found(void) {
      if constexpr (std::is_same<T, glm_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::glm_found();
   };
   

/*!
\brief Get fglm (Lagrange mutlipler flux function of GLM MHD) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   fglm_t& fglm(void) {
      if constexpr (std::is_same<T, fglm_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fglm();
   };

/*!
\brief Get fglm (Lagrange mutlipler flux function of GLM MHD) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const fglm_t& fglm(void) const {
      if constexpr (std::is_same<T, fglm_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::fglm();
   };


/*!
\brief Whether fglm (Lagrange mutlipler flux function of GLM MHD) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool fglm_found(void) {
      if constexpr (std::is_same<T, fglm_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::fglm_found();
   };
   

/*!
\brief Get ele (Electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ele_t& ele(void) {
      if constexpr (std::is_same<T, ele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ele();
   };

/*!
\brief Get ele (Electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ele_t& ele(void) const {
      if constexpr (std::is_same<T, ele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ele();
   };


/*!
\brief Whether ele (Electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool ele_found(void) {
      if constexpr (std::is_same<T, ele_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::ele_found();
   };
   

/*!
\brief Get Mmag (Magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Mmag_t& Mmag(void) {
      if constexpr (std::is_same<T, Mmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Mmag();
   };

/*!
\brief Get Mmag (Magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Mmag_t& Mmag(void) const {
      if constexpr (std::is_same<T, Mmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Mmag();
   };


/*!
\brief Whether Mmag (Magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Mmag_found(void) {
      if constexpr (std::is_same<T, Mmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Mmag_found();
   };
   

/*!
\brief Get Umag (Magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Umag_t& Umag(void) {
      if constexpr (std::is_same<T, Umag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Umag();
   };

/*!
\brief Get Umag (Magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Umag_t& Umag(void) const {
      if constexpr (std::is_same<T, Umag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Umag();
   };


/*!
\brief Whether Umag (Magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Umag_found(void) {
      if constexpr (std::is_same<T, Umag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Umag_found();
   };
   

/*!
\brief Get Gvel (Gradient of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Gvel_t& Gvel(void) {
      if constexpr (std::is_same<T, Gvel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gvel();
   };

/*!
\brief Get Gvel (Gradient of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Gvel_t& Gvel(void) const {
      if constexpr (std::is_same<T, Gvel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gvel();
   };


/*!
\brief Whether Gvel (Gradient of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Gvel_found(void) {
      if constexpr (std::is_same<T, Gvel_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Gvel_found();
   };
   

/*!
\brief Get Gele (Gradient of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Gele_t& Gele(void) {
      if constexpr (std::is_same<T, Gele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gele();
   };

/*!
\brief Get Gele (Gradient of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Gele_t& Gele(void) const {
      if constexpr (std::is_same<T, Gele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gele();
   };


/*!
\brief Whether Gele (Gradient of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Gele_found(void) {
      if constexpr (std::is_same<T, Gele_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Gele_found();
   };
   

/*!
\brief Get Gmag (Gradient of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Gmag_t& Gmag(void) {
      if constexpr (std::is_same<T, Gmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gmag();
   };

/*!
\brief Get Gmag (Gradient of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Gmag_t& Gmag(void) const {
      if constexpr (std::is_same<T, Gmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Gmag();
   };


/*!
\brief Whether Gmag (Gradient of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Gmag_found(void) {
      if constexpr (std::is_same<T, Gmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Gmag_found();
   };
   

/*!
\brief Get GMmag (Gradient of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GMmag_t& GMmag(void) {
      if constexpr (std::is_same<T, GMmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GMmag();
   };

/*!
\brief Get GMmag (Gradient of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GMmag_t& GMmag(void) const {
      if constexpr (std::is_same<T, GMmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GMmag();
   };


/*!
\brief Whether GMmag (Gradient of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool GMmag_found(void) {
      if constexpr (std::is_same<T, GMmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::GMmag_found();
   };
   

/*!
\brief Get GUmag (Gradient of magnetic field direction ) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GUmag_t& GUmag(void) {
      if constexpr (std::is_same<T, GUmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GUmag();
   };

/*!
\brief Get GUmag (Gradient of magnetic field direction ) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GUmag_t& GUmag(void) const {
      if constexpr (std::is_same<T, GUmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GUmag();
   };


/*!
\brief Whether GUmag (Gradient of magnetic field direction ) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool GUmag_found(void) {
      if constexpr (std::is_same<T, GUmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::GUmag_found();
   };
   

/*!
\brief Get Dvel (Time derivative of velocity field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Dvel_t& Dvel(void) {
      if constexpr (std::is_same<T, Dvel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dvel();
   };

/*!
\brief Get Dvel (Time derivative of velocity field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Dvel_t& Dvel(void) const {
      if constexpr (std::is_same<T, Dvel_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dvel();
   };


/*!
\brief Whether Dvel (Time derivative of velocity field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Dvel_found(void) {
      if constexpr (std::is_same<T, Dvel_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Dvel_found();
   };
   

/*!
\brief Get Dele (Time derivative of electric field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Dele_t& Dele(void) {
      if constexpr (std::is_same<T, Dele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dele();
   };

/*!
\brief Get Dele (Time derivative of electric field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Dele_t& Dele(void) const {
      if constexpr (std::is_same<T, Dele_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dele();
   };


/*!
\brief Whether Dele (Time derivative of electric field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Dele_found(void) {
      if constexpr (std::is_same<T, Dele_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Dele_found();
   };
   

/*!
\brief Get Dmag (Time derivative of magnetic field) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Dmag_t& Dmag(void) {
      if constexpr (std::is_same<T, Dmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dmag();
   };

/*!
\brief Get Dmag (Time derivative of magnetic field) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Dmag_t& Dmag(void) const {
      if constexpr (std::is_same<T, Dmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Dmag();
   };


/*!
\brief Whether Dmag (Time derivative of magnetic field) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Dmag_found(void) {
      if constexpr (std::is_same<T, Dmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Dmag_found();
   };
   

/*!
\brief Get DMmag (Time derivative of magnetic field magnitude) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DMmag_t& DMmag(void) {
      if constexpr (std::is_same<T, DMmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DMmag();
   };

/*!
\brief Get DMmag (Time derivative of magnetic field magnitude) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DMmag_t& DMmag(void) const {
      if constexpr (std::is_same<T, DMmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DMmag();
   };


/*!
\brief Whether DMmag (Time derivative of magnetic field magnitude) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DMmag_found(void) {
      if constexpr (std::is_same<T, DMmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::DMmag_found();
   };
   

/*!
\brief Get DUmag (Time derivative of magnetic field direction) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DUmag_t& DUmag(void) {
      if constexpr (std::is_same<T, DUmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DUmag();
   };

/*!
\brief Get DUmag (Time derivative of magnetic field direction) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DUmag_t& DUmag(void) const {
      if constexpr (std::is_same<T, DUmag_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DUmag();
   };


/*!
\brief Whether DUmag (Time derivative of magnetic field direction) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DUmag_found(void) {
      if constexpr (std::is_same<T, DUmag_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::DUmag_found();
   };
   

/*!
\brief Get PrimitiveStateGASDYN (Variables of the primitive form for a gas dynamics model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveStateGASDYN_t& PrimitiveStateGASDYN(void) {
      if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateGASDYN();
   };

/*!
\brief Get PrimitiveStateGASDYN (Variables of the primitive form for a gas dynamics model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveStateGASDYN_t& PrimitiveStateGASDYN(void) const {
      if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateGASDYN();
   };


/*!
\brief Whether PrimitiveStateGASDYN (Variables of the primitive form for a gas dynamics model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool PrimitiveStateGASDYN_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::PrimitiveStateGASDYN_found();
   };
   

/*!
\brief Get ConservedStateGASDYN (Variables of the conserved form for a gas dynamics model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedStateGASDYN_t& ConservedStateGASDYN(void) {
      if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateGASDYN();
   };

/*!
\brief Get ConservedStateGASDYN (Variables of the conserved form for a gas dynamics model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedStateGASDYN_t& ConservedStateGASDYN(void) const {
      if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateGASDYN();
   };


/*!
\brief Whether ConservedStateGASDYN (Variables of the conserved form for a gas dynamics model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool ConservedStateGASDYN_found(void) {
      if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::ConservedStateGASDYN_found();
   };
   

/*!
\brief Get FluxFunctionGASDYN (Variables of the flux function for a gas dynamics model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FluxFunctionGASDYN_t& FluxFunctionGASDYN(void) {
      if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionGASDYN();
   };

/*!
\brief Get FluxFunctionGASDYN (Variables of the flux function for a gas dynamics model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FluxFunctionGASDYN_t& FluxFunctionGASDYN(void) const {
      if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionGASDYN();
   };


/*!
\brief Whether FluxFunctionGASDYN (Variables of the flux function for a gas dynamics model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FluxFunctionGASDYN_found(void) {
      if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::FluxFunctionGASDYN_found();
   };
   

/*!
\brief Get PrimitiveStateMHD (Variables of the primitive form for an MHD model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveStateMHD_t& PrimitiveStateMHD(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD();
   };

/*!
\brief Get PrimitiveStateMHD (Variables of the primitive form for an MHD model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveStateMHD_t& PrimitiveStateMHD(void) const {
      if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD();
   };


/*!
\brief Whether PrimitiveStateMHD (Variables of the primitive form for an MHD model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool PrimitiveStateMHD_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD_found();
   };
   

/*!
\brief Get ConservedStateMHD (Variables of the conserved form for an MHD model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedStateMHD_t& ConservedStateMHD(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateMHD();
   };

/*!
\brief Get ConservedStateMHD (Variables of the conserved form for an MHD model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedStateMHD_t& ConservedStateMHD(void) const {
      if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateMHD();
   };


/*!
\brief Whether ConservedStateMHD (Variables of the conserved form for an MHD model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool ConservedStateMHD_found(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::ConservedStateMHD_found();
   };
   

/*!
\brief Get FluxFunctionMHD (Variables of the flux function for an MHD model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FluxFunctionMHD_t& FluxFunctionMHD(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD();
   };

/*!
\brief Get FluxFunctionMHD (Variables of the flux function for an MHD model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FluxFunctionMHD_t& FluxFunctionMHD(void) const {
      if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD();
   };


/*!
\brief Whether FluxFunctionMHD (Variables of the flux function for an MHD model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FluxFunctionMHD_found(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD_found();
   };
   

/*!
\brief Get PrimitiveStateMHD_GLM (Variables of the primitive form for an MHD-GLM model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   PrimitiveStateMHD_GLM_t& PrimitiveStateMHD_GLM(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD_GLM();
   };

/*!
\brief Get PrimitiveStateMHD_GLM (Variables of the primitive form for an MHD-GLM model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const PrimitiveStateMHD_GLM_t& PrimitiveStateMHD_GLM(void) const {
      if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD_GLM();
   };


/*!
\brief Whether PrimitiveStateMHD_GLM (Variables of the primitive form for an MHD-GLM model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool PrimitiveStateMHD_GLM_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::PrimitiveStateMHD_GLM_found();
   };
   

/*!
\brief Get ConservedStateMHD_GLM (Variables of the conserved form for an MHD-GLM model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   ConservedStateMHD_GLM_t& ConservedStateMHD_GLM(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateMHD_GLM();
   };

/*!
\brief Get ConservedStateMHD_GLM (Variables of the conserved form for an MHD-GLM model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const ConservedStateMHD_GLM_t& ConservedStateMHD_GLM(void) const {
      if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::ConservedStateMHD_GLM();
   };


/*!
\brief Whether ConservedStateMHD_GLM (Variables of the conserved form for an MHD-GLM model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool ConservedStateMHD_GLM_found(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::ConservedStateMHD_GLM_found();
   };
   

/*!
\brief Get FluxFunctionMHD_GLM (Variables of the flux function for an MHD-GLM model) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   FluxFunctionMHD_GLM_t& FluxFunctionMHD_GLM(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD_GLM();
   };

/*!
\brief Get FluxFunctionMHD_GLM (Variables of the flux function for an MHD-GLM model) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const FluxFunctionMHD_GLM_t& FluxFunctionMHD_GLM(void) const {
      if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD_GLM();
   };


/*!
\brief Whether FluxFunctionMHD_GLM (Variables of the flux function for an MHD-GLM model) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool FluxFunctionMHD_GLM_found(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::FluxFunctionMHD_GLM_found();
   };
   

/*!
\brief Get Bdata (Magnetic field data group) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   Bdata_t& Bdata(void) {
      if constexpr (std::is_same<T, Bdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Bdata();
   };

/*!
\brief Get Bdata (Magnetic field data group) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const Bdata_t& Bdata(void) const {
      if constexpr (std::is_same<T, Bdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::Bdata();
   };


/*!
\brief Whether Bdata (Magnetic field data group) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool Bdata_found(void) {
      if constexpr (std::is_same<T, Bdata_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::Bdata_found();
   };
   

/*!
\brief Get GBdata (Magnetic field data group (gradients/spatial derivatives)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   GBdata_t& GBdata(void) {
      if constexpr (std::is_same<T, GBdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GBdata();
   };

/*!
\brief Get GBdata (Magnetic field data group (gradients/spatial derivatives)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const GBdata_t& GBdata(void) const {
      if constexpr (std::is_same<T, GBdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::GBdata();
   };


/*!
\brief Whether GBdata (Magnetic field data group (gradients/spatial derivatives)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool GBdata_found(void) {
      if constexpr (std::is_same<T, GBdata_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::GBdata_found();
   };
   

/*!
\brief Get DBdata (Magnetic field data group (time derivatives)) from the data type, as lvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   DBdata_t& DBdata(void) {
      if constexpr (std::is_same<T, DBdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DBdata();
   };

/*!
\brief Get DBdata (Magnetic field data group (time derivatives)) from the data type, as const rvalue.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   const DBdata_t& DBdata(void) const {
      if constexpr (std::is_same<T, DBdata_t>::value)
         return data;
      else
         return MHDtuple<Ts...>::DBdata();
   };


/*!
\brief Whether DBdata (Magnetic field data group (time derivatives)) is in the data type.
\author Lucius Schoenbaum
\date 3/25/2025
*/
   bool DBdata_found(void) {
      if constexpr (std::is_same<T, DBdata_t>::value)
         return true;
      else
         return MHDtuple<Ts...>::DBdata_found();
   };
   

   // END(variables/generate, class)


/*!
\author Lucius Schoenbaum
\date 05/28/2025
\return string representation of state, for testing purposes
*/
   std::string str(bool recursive = false) const {
      std::string out;
      if (!recursive) out += "{";
      out += data.str() + ", " + MHDtuple<Ts...>::str(true);
      if (!recursive) out += "}";
      return out;
   }

};


/*!
\brief Base for MHDtuple data type construction.
\author Lucius Schoenbaum
\author Vladimir Florinski
\note There is no doxygen documentation for features in this class,
as the information is only relevant to the implementation.
*/
template <typename T>
struct MHDtuple<T> {

protected:

   T data;

   template <typename Function>
   void visit_unpacked(std::size_t i, Function&& f, auto&&... others) {
      if (i == 0)
         f(data, others.data...);
      else
         throw std::out_of_range("[MHDtuple] out of range");
   }

   template <typename Function>
   void foreach_unpacked(Function&& f, auto&&... others) {
      f(data, others.data...);
   }

public:

   MHDtuple(void) = default;

   explicit MHDtuple(T in):
       data(in)
   {};

   MHDtuple& operator=(const MHDtuple& other) {
      data = other.data;
      return *this;
   };

   size_t size() const {
      return 1;
   }
  
   const T& top() const {
      return data;
   }

   T& top() {
      return data;
   }

   std::any operator[](std::size_t index) const {
      if (index == 0)
         return data;
      else
         throw std::out_of_range("[MHDtuple] out of range");
   }

   template <typename Function, typename Others>
   void visit(std::size_t i, Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               visit_unpacked(i, std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function, typename Others>
   void foreach(Function&& f, Others&& others) {
      std::apply(
            [&](auto&&... others) {
               foreach_unpacked(std::forward<Function>(f), std::forward<decltype(others)>(others)...);
            },
            std::forward<Others>(others)
      );
   }

   template <typename Function>
   void foreach(Function&& f) {
      f(data);
   }

   // BEGIN(variables/generate, base)

   den_t& den(void) {
      if constexpr (std::is_same<T, den_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] den (Fluid density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const den_t& den(void) const {
   if constexpr (std::is_same<T, den_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] den (Fluid density field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool den_found(void) {
      if constexpr (std::is_same<T, den_t>::value)
         return true;
      else
         return false;
   };

   fden_t& fden(void) {
      if constexpr (std::is_same<T, fden_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] fden (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const fden_t& fden(void) const {
   if constexpr (std::is_same<T, fden_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] fden (Fluid density flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool fden_found(void) {
      if constexpr (std::is_same<T, fden_t>::value)
         return true;
      else
         return false;
   };

   prs_t& prs(void) {
      if constexpr (std::is_same<T, prs_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] prs (Fluid pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const prs_t& prs(void) const {
   if constexpr (std::is_same<T, prs_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] prs (Fluid pressure field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool prs_found(void) {
      if constexpr (std::is_same<T, prs_t>::value)
         return true;
      else
         return false;
   };

   enr_t& enr(void) {
      if constexpr (std::is_same<T, enr_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] enr (Fluid energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const enr_t& enr(void) const {
   if constexpr (std::is_same<T, enr_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] enr (Fluid energy field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool enr_found(void) {
      if constexpr (std::is_same<T, enr_t>::value)
         return true;
      else
         return false;
   };

   fenr_t& fenr(void) {
      if constexpr (std::is_same<T, fenr_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] fenr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const fenr_t& fenr(void) const {
   if constexpr (std::is_same<T, fenr_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] fenr (Fluid energy flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool fenr_found(void) {
      if constexpr (std::is_same<T, fenr_t>::value)
         return true;
      else
         return false;
   };

   vel_t& vel(void) {
      if constexpr (std::is_same<T, vel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] vel (Fluid velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const vel_t& vel(void) const {
   if constexpr (std::is_same<T, vel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] vel (Fluid velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool vel_found(void) {
      if constexpr (std::is_same<T, vel_t>::value)
         return true;
      else
         return false;
   };

   mom_t& mom(void) {
      if constexpr (std::is_same<T, mom_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] mom (Fluid momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const mom_t& mom(void) const {
   if constexpr (std::is_same<T, mom_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] mom (Fluid momentum field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool mom_found(void) {
      if constexpr (std::is_same<T, mom_t>::value)
         return true;
      else
         return false;
   };

   fmom_t& fmom(void) {
      if constexpr (std::is_same<T, fmom_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] fmom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const fmom_t& fmom(void) const {
   if constexpr (std::is_same<T, fmom_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] fmom (Fluid momentum flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool fmom_found(void) {
      if constexpr (std::is_same<T, fmom_t>::value)
         return true;
      else
         return false;
   };

   mag_t& mag(void) {
      if constexpr (std::is_same<T, mag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const mag_t& mag(void) const {
   if constexpr (std::is_same<T, mag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] mag (Magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool mag_found(void) {
      if constexpr (std::is_same<T, mag_t>::value)
         return true;
      else
         return false;
   };

   fmag_t& fmag(void) {
      if constexpr (std::is_same<T, fmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] fmag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const fmag_t& fmag(void) const {
   if constexpr (std::is_same<T, fmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] fmag (Magnetic field flux function) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool fmag_found(void) {
      if constexpr (std::is_same<T, fmag_t>::value)
         return true;
      else
         return false;
   };

   glm_t& glm(void) {
      if constexpr (std::is_same<T, glm_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const glm_t& glm(void) const {
   if constexpr (std::is_same<T, glm_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] glm (Lagrange multiplier field of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool glm_found(void) {
      if constexpr (std::is_same<T, glm_t>::value)
         return true;
      else
         return false;
   };

   fglm_t& fglm(void) {
      if constexpr (std::is_same<T, fglm_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] fglm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const fglm_t& fglm(void) const {
   if constexpr (std::is_same<T, fglm_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] fglm (Lagrange mutlipler flux function of GLM MHD) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool fglm_found(void) {
      if constexpr (std::is_same<T, fglm_t>::value)
         return true;
      else
         return false;
   };

   ele_t& ele(void) {
      if constexpr (std::is_same<T, ele_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] ele (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const ele_t& ele(void) const {
   if constexpr (std::is_same<T, ele_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] ele (Electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool ele_found(void) {
      if constexpr (std::is_same<T, ele_t>::value)
         return true;
      else
         return false;
   };

   Mmag_t& Mmag(void) {
      if constexpr (std::is_same<T, Mmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Mmag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Mmag_t& Mmag(void) const {
   if constexpr (std::is_same<T, Mmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Mmag (Magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Mmag_found(void) {
      if constexpr (std::is_same<T, Mmag_t>::value)
         return true;
      else
         return false;
   };

   Umag_t& Umag(void) {
      if constexpr (std::is_same<T, Umag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Umag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Umag_t& Umag(void) const {
   if constexpr (std::is_same<T, Umag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Umag (Magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Umag_found(void) {
      if constexpr (std::is_same<T, Umag_t>::value)
         return true;
      else
         return false;
   };

   Gvel_t& Gvel(void) {
      if constexpr (std::is_same<T, Gvel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Gvel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Gvel_t& Gvel(void) const {
   if constexpr (std::is_same<T, Gvel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Gvel (Gradient of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Gvel_found(void) {
      if constexpr (std::is_same<T, Gvel_t>::value)
         return true;
      else
         return false;
   };

   Gele_t& Gele(void) {
      if constexpr (std::is_same<T, Gele_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Gele (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Gele_t& Gele(void) const {
   if constexpr (std::is_same<T, Gele_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Gele (Gradient of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Gele_found(void) {
      if constexpr (std::is_same<T, Gele_t>::value)
         return true;
      else
         return false;
   };

   Gmag_t& Gmag(void) {
      if constexpr (std::is_same<T, Gmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Gmag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Gmag_t& Gmag(void) const {
   if constexpr (std::is_same<T, Gmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Gmag (Gradient of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Gmag_found(void) {
      if constexpr (std::is_same<T, Gmag_t>::value)
         return true;
      else
         return false;
   };

   GMmag_t& GMmag(void) {
      if constexpr (std::is_same<T, GMmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] GMmag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const GMmag_t& GMmag(void) const {
   if constexpr (std::is_same<T, GMmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] GMmag (Gradient of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool GMmag_found(void) {
      if constexpr (std::is_same<T, GMmag_t>::value)
         return true;
      else
         return false;
   };

   GUmag_t& GUmag(void) {
      if constexpr (std::is_same<T, GUmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] GUmag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const GUmag_t& GUmag(void) const {
   if constexpr (std::is_same<T, GUmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] GUmag (Gradient of magnetic field direction ) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool GUmag_found(void) {
      if constexpr (std::is_same<T, GUmag_t>::value)
         return true;
      else
         return false;
   };

   Dvel_t& Dvel(void) {
      if constexpr (std::is_same<T, Dvel_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Dvel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Dvel_t& Dvel(void) const {
   if constexpr (std::is_same<T, Dvel_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Dvel (Time derivative of velocity field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Dvel_found(void) {
      if constexpr (std::is_same<T, Dvel_t>::value)
         return true;
      else
         return false;
   };

   Dele_t& Dele(void) {
      if constexpr (std::is_same<T, Dele_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Dele (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Dele_t& Dele(void) const {
   if constexpr (std::is_same<T, Dele_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Dele (Time derivative of electric field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Dele_found(void) {
      if constexpr (std::is_same<T, Dele_t>::value)
         return true;
      else
         return false;
   };

   Dmag_t& Dmag(void) {
      if constexpr (std::is_same<T, Dmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Dmag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Dmag_t& Dmag(void) const {
   if constexpr (std::is_same<T, Dmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Dmag (Time derivative of magnetic field) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Dmag_found(void) {
      if constexpr (std::is_same<T, Dmag_t>::value)
         return true;
      else
         return false;
   };

   DMmag_t& DMmag(void) {
      if constexpr (std::is_same<T, DMmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] DMmag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DMmag_t& DMmag(void) const {
   if constexpr (std::is_same<T, DMmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] DMmag (Time derivative of magnetic field magnitude) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DMmag_found(void) {
      if constexpr (std::is_same<T, DMmag_t>::value)
         return true;
      else
         return false;
   };

   DUmag_t& DUmag(void) {
      if constexpr (std::is_same<T, DUmag_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] DUmag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DUmag_t& DUmag(void) const {
   if constexpr (std::is_same<T, DUmag_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] DUmag (Time derivative of magnetic field direction) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DUmag_found(void) {
      if constexpr (std::is_same<T, DUmag_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveStateGASDYN_t& PrimitiveStateGASDYN(void) {
      if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] PrimitiveStateGASDYN (Variables of the primitive form for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const PrimitiveStateGASDYN_t& PrimitiveStateGASDYN(void) const {
   if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] PrimitiveStateGASDYN (Variables of the primitive form for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool PrimitiveStateGASDYN_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateGASDYN_t>::value)
         return true;
      else
         return false;
   };

   ConservedStateGASDYN_t& ConservedStateGASDYN(void) {
      if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] ConservedStateGASDYN (Variables of the conserved form for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const ConservedStateGASDYN_t& ConservedStateGASDYN(void) const {
   if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] ConservedStateGASDYN (Variables of the conserved form for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool ConservedStateGASDYN_found(void) {
      if constexpr (std::is_same<T, ConservedStateGASDYN_t>::value)
         return true;
      else
         return false;
   };

   FluxFunctionGASDYN_t& FluxFunctionGASDYN(void) {
      if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] FluxFunctionGASDYN (Variables of the flux function for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FluxFunctionGASDYN_t& FluxFunctionGASDYN(void) const {
   if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] FluxFunctionGASDYN (Variables of the flux function for a gas dynamics model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FluxFunctionGASDYN_found(void) {
      if constexpr (std::is_same<T, FluxFunctionGASDYN_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveStateMHD_t& PrimitiveStateMHD(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] PrimitiveStateMHD (Variables of the primitive form for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const PrimitiveStateMHD_t& PrimitiveStateMHD(void) const {
   if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] PrimitiveStateMHD (Variables of the primitive form for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool PrimitiveStateMHD_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_t>::value)
         return true;
      else
         return false;
   };

   ConservedStateMHD_t& ConservedStateMHD(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] ConservedStateMHD (Variables of the conserved form for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const ConservedStateMHD_t& ConservedStateMHD(void) const {
   if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] ConservedStateMHD (Variables of the conserved form for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool ConservedStateMHD_found(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_t>::value)
         return true;
      else
         return false;
   };

   FluxFunctionMHD_t& FluxFunctionMHD(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] FluxFunctionMHD (Variables of the flux function for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FluxFunctionMHD_t& FluxFunctionMHD(void) const {
   if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] FluxFunctionMHD (Variables of the flux function for an MHD model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FluxFunctionMHD_found(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_t>::value)
         return true;
      else
         return false;
   };

   PrimitiveStateMHD_GLM_t& PrimitiveStateMHD_GLM(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] PrimitiveStateMHD_GLM (Variables of the primitive form for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const PrimitiveStateMHD_GLM_t& PrimitiveStateMHD_GLM(void) const {
   if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] PrimitiveStateMHD_GLM (Variables of the primitive form for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool PrimitiveStateMHD_GLM_found(void) {
      if constexpr (std::is_same<T, PrimitiveStateMHD_GLM_t>::value)
         return true;
      else
         return false;
   };

   ConservedStateMHD_GLM_t& ConservedStateMHD_GLM(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] ConservedStateMHD_GLM (Variables of the conserved form for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const ConservedStateMHD_GLM_t& ConservedStateMHD_GLM(void) const {
   if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] ConservedStateMHD_GLM (Variables of the conserved form for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool ConservedStateMHD_GLM_found(void) {
      if constexpr (std::is_same<T, ConservedStateMHD_GLM_t>::value)
         return true;
      else
         return false;
   };

   FluxFunctionMHD_GLM_t& FluxFunctionMHD_GLM(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] FluxFunctionMHD_GLM (Variables of the flux function for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const FluxFunctionMHD_GLM_t& FluxFunctionMHD_GLM(void) const {
   if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] FluxFunctionMHD_GLM (Variables of the flux function for an MHD-GLM model) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool FluxFunctionMHD_GLM_found(void) {
      if constexpr (std::is_same<T, FluxFunctionMHD_GLM_t>::value)
         return true;
      else
         return false;
   };

   Bdata_t& Bdata(void) {
      if constexpr (std::is_same<T, Bdata_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] Bdata (Magnetic field data group) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const Bdata_t& Bdata(void) const {
   if constexpr (std::is_same<T, Bdata_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] Bdata (Magnetic field data group) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool Bdata_found(void) {
      if constexpr (std::is_same<T, Bdata_t>::value)
         return true;
      else
         return false;
   };

   GBdata_t& GBdata(void) {
      if constexpr (std::is_same<T, GBdata_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] GBdata (Magnetic field data group (gradients/spatial derivatives)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const GBdata_t& GBdata(void) const {
   if constexpr (std::is_same<T, GBdata_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] GBdata (Magnetic field data group (gradients/spatial derivatives)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool GBdata_found(void) {
      if constexpr (std::is_same<T, GBdata_t>::value)
         return true;
      else
         return false;
   };

   DBdata_t& DBdata(void) {
      if constexpr (std::is_same<T, DBdata_t>::value)
         return data;
      else
        throw std::invalid_argument( "[MHDtuple] DBdata (Magnetic field data group (time derivatives)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
  const DBdata_t& DBdata(void) const {
   if constexpr (std::is_same<T, DBdata_t>::value)
      return data;
   else
      throw std::invalid_argument( "[MHDtuple] DBdata (Magnetic field data group (time derivatives)) was not found: the tuple does not contain the requested value type. You can add this value type when you build the tuple type." );
   };
   
   bool DBdata_found(void) {
      if constexpr (std::is_same<T, DBdata_t>::value)
         return true;
      else
         return false;
   };

   // END(variables/generate, base)

   std::string str(bool recursive = false) const {
      if (recursive)
         return data.str();
      else
         return "{" + data.str() + "}";
   }

};

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup const MHDtuple type
\return The `I`th member of tuple, for template argument integer `I`
 \note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, typename T, typename... Ts>
decltype(auto) get(const MHDtuple<T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I-1>(static_cast<const MHDtuple<Ts...>&>(tup));
}

/*!
\author Lucius Schoenbaum
\date 06/02/2025
\param[in] tup MHDtuple type
\return The `I`th member of tuple, for template argument integer `I`
\note The calling pattern is the same as that of std::get.
\note The value of template argument `I` must be known at compile time,
which can constraint usage in some situations. In these cases you may be
able use class method foreach() with one of the argument signatures.
*/
template <std::size_t I, typename T, typename... Ts>
decltype(auto) get(MHDtuple<T, Ts...>& tup) {
   if constexpr (I == 0)
      return tup.top();
   else
      return get<I - 1>(static_cast<MHDtuple<Ts...> &>(tup));
}

};

#endif
